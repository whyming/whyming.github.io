<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hysteria-go 使用及源码学习]]></title>
    <url>%2Fhystrix-go-introduction.html</url>
    <content type="text"><![CDATA[hysteria-go 使用及源码学习，介绍hystrix-go的参数及意义，然后通过源码分析每个参数的实现方式 [TOC] 入口函数 hystrix主要入口有4个 Do , Doc, Go, GoC, 这几个从名字上， Do和 DoC 是同步动作， Go和 GoC是异步执行。 Do和 DoC的区别是，带 C的 第一个参数是 context.Context，而不带 C的就是内部用 context.Background()代替而已，其他地方没有任何区别。 Go和 GoC也是一样的。 看下 Do的代码就知道了 123456789101112 func Do(name string, run runFunc, fallback fallbackFunc) error &#123; runC := func(ctx context.Context) error &#123; return run() &#125; var fallbackC fallbackFuncC if fallback != nil &#123; fallbackC = func(ctx context.Context, err error) error &#123; return fallback(err) &#125; &#125; return DoC(context.Background(), name, runC, fallbackC)&#125; 每个func参数都包装了一下，仅此而已 然后在看下 Do和 Go的区别，一个是同步一个是异步。另外一个主要的区别就是两个函数的返回值类型， Do返回的是 error，而Go返回的是 chan error，看到chan 又看到go，应该可以想到goroutine。是的， Go内部就是创建一个routine，然后通过 chan error通信实现的。 前面提到 Go是对 GoC的包装， Do是对 Doc的包装。除此之外 Doc也是对 Goc的包装，这样，所有接口都是 GoC或者 GoC的包装了。 Doc是对 GoC的包装，通过一小段代码就可以知道了。 123456 select &#123; case &lt;-done: return nil case err := &lt;-errChan: return err &#125; 通过 select阻塞直到抛出错误或者执行成功 配置参数 配置参数主要有两个入口 Configure(cmds map[string]CommandConfig) 和 ConfigureCommand(name string, config CommandConfig)实际上，前者就是对后者的包装。 12345 func Configure(cmds map[string]CommandConfig) &#123; for k, v := range cmds &#123; ConfigureCommand(k, v) &#125;&#125; ConmandConfig支持5个参数， Timeout — 待续]]></content>
      <tags>
        <tag>golang</tag>
        <tag>go</tag>
        <tag>hystrix-go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-5]]></title>
    <url>%2FARTS-5.html</url>
    <content type="text"><![CDATA[A: Divide Two Integers R: Encrypting Streams in Go T: Etcd watch的是前缀，而不是固定key S: A: Divide Two Integers Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1: 123 &gt; Input: dividend = 10, divisor = 3&gt; Output: 3&gt; Example 2: 123 &gt; Input: dividend = 7, divisor = -3&gt; Output: -2&gt; Note: Both dividend and divisor will be 32-bit signed integers. The divisor will never be 0. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231, 231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows. 1234567891011121314151617181920212223242526272829 func divide(dividend int, divisor int) int &#123; positive := (dividend &gt; 0) == (divisor &gt; 0) abs := func(a int) int &#123; if a &gt; 0 &#123; return a &#125; return -a &#125; dividend, divisor = abs(dividend), abs(divisor) result := 0 for dividend &gt;= divisor &#123; tmp := divisor mult := 1 for dividend &gt;= tmp &#123; dividend -= tmp result += mult tmp = tmp &lt;&lt; 1 mult = mult &lt;&lt; 1 &#125; &#125; if !positive &#123; result = -result &#125; max := 1&lt;&lt;31 - 1 if result &gt; max &#123; return max &#125; return result&#125; 这道题第一次完成时，计算没有错误，但是超时了，第一次知道LeetCode加时间要求，一时间没反应过来，因为受乘法影响，忽略了位移。参考discuss才豁然明白，可以逐渐放大除数，因为减掉除数的N倍，不影响结果。 R: Encrypting Streams in Go 流式加密，作者介绍自己的工作中会备份多种数据库。但是因为是用户敏感信息，需要加密，开始的时候，加密文件比较小，直接在内存中处理，最大的备份文件没有超过2G。但是随着业务增加，备份文件越来越大，无法在内存中处理，需要流式处理，使用了golang内置的 crypto/cipher库，并且在此基础上做了一点封装，能够复用内存。这样，无论文件多大，都不会重复申请内存。 T: Etcd watch的是前缀，而不是固定key Etcd的watch功能，监听的是前缀，回调函数返回的event可以得到具体的key，这样能通过监听公共前缀，实现只注册一个回调，完成多个key的监听。 S:]]></content>
      <tags>
        <tag>ARTS</tag>
        <tag>golang</tag>
        <tag>go</tag>
        <tag>打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-第四周]]></title>
    <url>%2FARTS-4.html</url>
    <content type="text"><![CDATA[A: Swap Nodes in Pairs R: Compile-time DI vs. Run-time DI T: jq 工具使用 S: A: Swap Nodes in Pairs Given a linked list, swap every two adjacent nodes and return its head. You may not modify the values in the list’s nodes, only nodes itself may be changed. Example: 12 &gt;Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.&gt; 12345678910111213141516171819 func swapPairs(head *ListNode) *ListNode &#123; if head == nil &#123; return nil &#125; else if head.Next == nil &#123; return head &#125; result := head.Next var last *ListNode for curr := head; curr != nil &amp;&amp; curr.Next != nil; curr = curr.Next &#123; if last != nil &#123; last.Next = curr.Next &#125; after := curr.Next.Next curr.Next.Next = curr curr.Next = after last = curr &#125; return result&#125; R: Compile-time DI vs. Run-time DI 依赖注入 T: jq 工具使用 jq是一款处理json的工具，用于命令行，支持复杂json的解析和处理，甚至可以加入一些编程性的操作，比如求和、map等 下载地址 S:]]></content>
      <tags>
        <tag>ARTS</tag>
        <tag>golang</tag>
        <tag>go</tag>
        <tag>打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-第三周]]></title>
    <url>%2FARTS-3.html</url>
    <content type="text"><![CDATA[ARTS打卡第三周 A: Letter Combinations of a Phone Number R:Why you should like sync.Pool T: 利用闭包构构造类型一致的不同错误 S: – [TOC] A: Letter Combinations of a Phone Number Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. 123 &gt; Input: &quot;23&quot;&gt; Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].&gt; 代码： 123456789101112131415161718192021222324252627282930313233343536 func letterCombinations(digits string) []string &#123; result := []string&#123;&#125; m := map[byte][]string&#123; '2': []string&#123;"a", "b", "c"&#125;, '3': []string&#123;"d", "e", "f"&#125;, '4': []string&#123;"g", "h", "i"&#125;, '5': []string&#123;"j", "k", "l"&#125;, '6': []string&#123;"m", "n", "o"&#125;, '7': []string&#123;"p", "q", "r", "s"&#125;, '8': []string&#123;"t", "u", "v"&#125;, '9': []string&#123;"w", "x", "y", "z"&#125;, &#125; more := func(pre string, suff byte) []string &#123; r := []string&#123;&#125; if ss, ok := m[suff]; ok &#123; for _, s := range ss &#123; r = append(r, pre+s) &#125; &#125; return r &#125; for _, b := range []byte(digits) &#123; tmp := []string&#123;&#125; if len(result) == 0 &#123; tmp = more("", b) &#125; else &#123; for _, r := range result &#123; tmp = append(tmp, more(r, b)...) &#125; &#125; result = tmp &#125; return result&#125; R: Why you should like sync.Pool 为什么你应该使用sync.Pool， 他能减少内存的使用 sync.Pool是什么？他是一个临时对象集合，这些对象可以单个被存储和提取 sync.Pool用法，需要在使用完成后reset并put back 性能测试： bytes.Buffer 44% 性能提升和非常多的内存减少 bufio.Writer, 5倍性能提升，内存减少为1/32 Decoding, 无明显提升，因为hard operation就是硬操作？ gzip， 45倍性能提升，内存降低为1/4982 结论：如果可以尽量使用sync.Pool，他能提高性能减少内存消耗 T: golang里可以通过闭包创建构造函数，比如创建error 1234567891011121314151617181920 type DbError struct&#123; name string msg string&#125;func (e DbError) Error() string &#123; return fmt.Sprintf("%s: %s", e.name, e.message)&#125;func IsDbError(e error) bool &#123; _, ok := e.(DbError) return ok&#125;func NewErrorGen(name string) func(string, ...interface&#123;&#125;) error &#123; return func(msg string, p ...interface&#123;&#125;) error &#123; return DbError&#123; name: name, message: fmt.Sprintf(msg, p...), &#125; &#125;&#125; 重点就是地下这个 NewErrorGen， 可以创建多个维度的不同的error，但又能知道这些error是同一个类型的错误 S：后补]]></content>
      <tags>
        <tag>golang</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS-第二周]]></title>
    <url>%2FARTS-2.html</url>
    <content type="text"><![CDATA[ARTS打卡第二周 A: leetcode 3Sum， Midum R：http断点续传协议TUS T: 利用git commit 回滚代码，阅读庞大项目 S：go-nats代码阅读 [TOC] A: leetcode 3Sum， Midum 实际做了3道题，不过 intToRoman和 romanToInt这两题难度较低，意义不大，于是尝试这道 3sum 自己的实现： 自己的实现 123456789101112131415161718192021222324252627282930313233343536373839404142 func threeSum(nums []int) [][]int &#123; if len(nums) == 0 &#123; return [][]int&#123;&#125; &#125; sort.Slice(nums, func(i, j int) bool &#123; return nums[j] &gt; nums[i] &#125;) positiveMap := map[int]int&#123;&#125; for index, i := range nums &#123; if i &gt;= 0 &#123; positiveMap[i] = index &#125; &#125; result := [][]int&#123;&#125; currA := nums[0] - 1 for i := 0; i &lt; len(nums)-1; i++ &#123; if nums[i] &gt; 0 &#123; break &#125; if currA == nums[i] &#123; continue &#125; currA = nums[i] currB := nums[0] - 1 for j := i + 1; j &lt; len(nums); j++ &#123; if currB == nums[j] &#123; continue &#125; currB = nums[j] target := 0 - (nums[i] + nums[j]) if c, ok := positiveMap[target]; ok &#123; if c &gt; j &#123; result = append(result, []int&#123; nums[i], nums[j], target, &#125;) &#125; &#125; &#125; &#125; return result&#125; 运行结果： Runtime: 936 ms, faster than 48.61% of Go online submissions for 3Sum. Memory Usage: 340.6 MB, less than 30.93% of Go online submissions for 3Sum. 参考大神代码后的结果： 1234567891011121314151617181920212223242526272829303132333435 func threeSum(nums []int) [][]int &#123; result := [][]int&#123;&#125; sort.Slice(nums, func(i, j int) bool &#123; return nums[i] &lt; nums[j] &#125;) for i := 0; i &lt; len(nums)-2 &amp;&amp; nums[i] &lt;= 0; i++ &#123; if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &#123; // 重复的跳过 continue &#125; // s指向数组开头即最小值，e指向最后，即最大值 s, e, target := i+1, len(nums)-1, 0-nums[i] for s &lt; e &#123; // fmt.Printf("nums %+v\n s: %d, e:%d\n", nums, s, e) if nums[s]+nums[e] == target &#123; result = append(result, []int&#123; nums[i], nums[s], nums[e], &#125;) for s &lt; e &amp;&amp; nums[s] == nums[s+1] &#123; s++ &#125; for s &lt; e &amp;&amp; nums[e] == nums[e-1] &#123; e-- &#125; s++ e-- &#125; else if nums[s]+nums[e] &gt; target &#123; // 结果大于逾期，需要最大值减小 e-- &#125; else &#123; s++ &#125; &#125; &#125; return result&#125; 运行结果： Runtime: 868 ms, faster than 91.25% of Go online submissions for 3Sum. Memory Usage: 205.1 MB, less than 98.97% of Go online submissions for 3Sum. R：http断点续传协议TUS Resumable file uploader: Understanding tus protocol 通过http方式解决大文件断点续传问题，主要通过三个步骤实现： http POST方法,创建文件，返回rest格式的文件地址 http PATCH方案更新文件，每次传入更新的 Upload-Offset和 Content-Length, http HEAD返回文件更新位置，即最后一次 PATCH的位置 T: 利用git commit 回滚代码，阅读庞大项目 这个技巧来自于公众号一个大神的推荐， 开源代码学习技巧 内容主要就是clone整个项目后，可以通过提交历史找到一个较早的可用提交，个人经验可以看tag名称，比如v0.01，v0.24,这种，或是看具体的commit message，这样可以看到最小功能的项目代码，理解最初意图，主要是降低阅读代价，然后不断向后移动提交位置，不仅可以逐步阅读完代码，还可以看到作者在每次更新的主要内容。 S：go-nats代码阅读 用上面提到的技巧，自己整理了一下第一版go-nats代码，很快就看懂了，接下来会阅读 v0.6，这样逐步完成整个项目阅读]]></content>
      <tags>
        <tag>ARTS</tag>
        <tag>golang</tag>
        <tag>go</tag>
        <tag>打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARTS 第一周]]></title>
    <url>%2FARTS-%E7%AC%AC%E4%B8%80%E5%91%A8.html</url>
    <content type="text"><![CDATA[《左耳听风》发起的ARTS挑战 Algorithm。 主要是为了编程训练和学习。每周至少做一个 leetcode 的算法题（先从Easy开始，然后再Medium，最后才Hard）。进行编程训练，如果不训练你看再多的算法书，你依然不会做算法题，看完书后，你需要训练。关于做Leetcode的的优势，你可以看一下我在coolshell上的文章 Leetcode 编程训练 - 酷 壳 - CoolShell。 Review：主要是为了学习英文，如果你的英文不行，你基本上无缘技术高手。所以，需要你阅读并点评至少一篇英文技术文章，我个人最喜欢去的地方是 http://Medium.com（需要梯子）以及各个公司的技术blog，如Netflix的。 Tip：主要是为了总结和归纳你在是常工作中所遇到的知识点。学习至少一个技术技巧。你在工作中遇到的问题，踩过的坑，学习的点滴知识。 Share：主要是为了建立你的影响力，能够输出价值观。分享一篇有观点和思考的技术文章。 作者：陈皓 Algorithm 上次写了几个题，这次接着继续主要是easy和medium 这次是medium： 字符串转数值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 func myAtoi(str string) int &#123; var ( isNegative = 0 validLen int32 startNum bool Max = 2 &lt;&lt; 30 MaxPre = 2 &lt;&lt; 30 / 10 ) l := len(str) var result intLOOP: for i := 0; i &lt; l; i++ &#123; switch &#123; case !startNum &amp;&amp; isNegative == 0 &amp;&amp; str[i] == ' ': continue case !startNum &amp;&amp; isNegative == 0 &amp;&amp; str[i] == '-': isNegative = -1 continue case !startNum &amp;&amp; isNegative == 0 &amp;&amp; str[i] == '+': isNegative = 1 continue case str[i] &lt; '0' || str[i] &gt; '9': break LOOP default: if isNegative == 0 &#123; isNegative = 1 &#125; if str[i] == '0' &amp;&amp; result == 0 &#123; continue &#125; startNum = true validLen++ &#125; if validLen &gt; 10 || result &gt; MaxPre || (result == MaxPre &amp;&amp; (isNegative == 1 &amp;&amp; str[i] &gt; '7' &amp;&amp; str[i] &lt;= '9' || isNegative == -1 &amp;&amp; str[i] == '9')) &#123; if isNegative == 1 &#123; result = Max - 1 break &#125; else &#123; result = Max break &#125; &#125; result = result*10 + (int(str[i]) - '0') &#125; if isNegative != 0 &#123; result = result * isNegative &#125; return result&#125; Review 英文阅读确实是短板，从简单的入手吧，顺便当作收藏资源 关于go应该知道的一些知识 go周报，大家都可以订阅一下，关于go的一些最新消息还有更新、文章、新闻等 go邮件列表1， go开发者论坛, 都是google自己家的，需要梯子，但是可以看到关于go的最新的讨论和发展 第三方论坛： reddit论坛， 博客： 号称top 20的golang博客的聚合，看上去还不错 github 项目： 千星项目搜索，千应该是受大家认可的项目了 GopherCon 开发者大会，这个看情况吧… Tip 刚好在写上面leetcode题的时候发现，go的字符型还是挺有意思的，当我按照下标去访问字符串元素的时候，得到的竟然是 uint8，同理，当定义一个字符的时候，其实也是使用了 uint8,其值就是对应的ascii码值，这样可以直接进行 +-操作，同时比较也很方便。 123456789 func main() &#123; s := "abcd" tt := reflect.TypeOf(s[0]) vv := reflect.ValueOf(s[0]) fmt.Printf("type is: %v\n", tt) fmt.Printf("value is: %v\n", vv)&#125;// type is: uint8// value is: 97 Share 先分享一篇别人现成的吧 Go高级实践：反射3定律]]></content>
      <tags>
        <tag>ARTS</tag>
        <tag>golang</tag>
        <tag>打卡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nsq源码学习笔记(二) --- nsqd消息订阅]]></title>
    <url>%2FNsq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-nsqd%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85.html</url>
    <content type="text"><![CDATA[nsqd.Main内部逻辑很少，启动了6个goroutine，下面简单说一下goroutine的作用 tcpserver，监听客户端连接，很重要，下面消息订阅就是在这里面发生的 httpserver，监听http请求，提供rest api 服务 httpsserver，监听https请求，其实和http的一样 queueScanLoop，应该是监听消息队列的，稍后回来填坑 lookupLoop ，和nsqlookupd通信的 statsdLoop， 状态同步 tcpserver 获取订阅消息 连接成功后，立刻读取前4个字节， [ ][ ][V][2],前两个空格应该是预留，这个是用来判断通信协议版本的，目前只有V2, 然后开始 prot.IOLoop, 这个是tcpserver最主要的事情了， 里面也主要包含两部分 启动 messagePump,这是一个goroutine，处理消息转发等 循环读取client发来的消息，解析成命令并执行，同时还包含了维护心跳 messagePump通过循环读取多个chan来实现消息读取，事件触发，其中就包含对订阅消息的转发 当client发送一个 SUB topicName Channel给nsqd时， nsqd在检查topic和channel合法性后，会创建一个新的channel，放入 subEventChan， messagePump监听并得到这个chan后，会继监听这个chan的消息，一旦这个channel有消息发来，则会将channel的消息转发给client，这样客户端就得到了订阅的消息推送。 channel的消息哪来的呢？原来在topic创建channel的时候，同时会把这channel加入topic的channel列表，当top接受到消息的时候，发送给列表中的每一个channel，这样可以实现一个topic，多个订阅channel都能得到消息。 另外因为topic在创建channel的时候使用的是 getOrCreateChannel从名字看就知道，如果已经存在这个名字的channel则直接返回已经存在的channel，如果不存在才创建。那么如果订阅了一个已经存在的channel，就是说别人也监听了的channel会怎么样呢，这个问题转换成了，如果一个go channel多出代码读取，将随机的的一个读到消息，所以订阅同一个channel的客户端将随机收到消息。听说这样设计是为了实现客户端的均衡，可以让多个客户端随机消费同一个channel]]></content>
      <tags>
        <tag>go</tag>
        <tag>Nsq</tag>
        <tag>源码学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法200题训练02-平衡二叉树]]></title>
    <url>%2F%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%8302-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>go</tag>
        <tag>算法</tag>
        <tag>二叉树</tag>
        <tag>平衡二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go的反射库reflect学习]]></title>
    <url>%2FGo%E7%9A%84%E5%8F%8D%E5%B0%84%E5%BA%93reflect%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[鉴于官方手册并不是每个方法都给出了example，描述有很多也不是很清楚，所以光从doc是不能完全理解这个库，还是要动起手来 reflect库提供了非常的多方法，但是这个库到底能做什么，不实际动手尝试一下还是没能理解。 接下来从最基础两个类型开始：Type和Value Type &amp; TypeOf 第一个重要的数据结构,先列一些稍后用的到的且好理解的 1234567891011121314151617181920212223242526272829303132 type Type interface &#123; // 调试常用，返回一个字符串表示的类型，比如[]map[string]int,表示一个map类型的切片 String() string // kind用到的也很多，返回的是类型，但是用int表示的，看代码理解吧 Kind() Kind // 返回元素的类型， 只有这些类型才有元素：Array、Chan、Map、Slice和Ptr，指针这个需要看代码理解 Elem() Type // 返回函数类型的参数个数，不是函数类型会panic，好理解 NumIn() int // 返回函数类型的第i个参数的类型，不是函数类型或是超过NumIn会panic In(i int) Type // 和参数类型对应，这个是返回的个数 NumOut() int // 和参数对应，返回参数的第i个是什么类型 Out(i int) Type // 返回map的key类型，不是map类型就会panic，好理解,和Elem() 对应返回元素类型 Key() Type // 返回Array的length，如果不是Array类型就panic，好理解 Len() int // struct 类型的field个数，如果不是struct类型panic，后面用的很多 NumField() int&#125; 什么时候，以及怎么用Type呢，来看 func TypeOf(i interface{}) Type 来两个简单的例子感受一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 var s strings = "abc"tp := reflect.TypeOf(s)tps := tp.String()fmt.Printf("string s type is: #%s#",tps)输出：string s type is: #string#继续：if tp.Kind() == reflect.String &#123; fmt.Println("s type is String")&#125; else &#123; fmt.Println("s type is NOT String")&#125;输出：s type is String继续：sa := [3]string&#123;"a", "b", "c"&#125;tp = reflect.TypeOf(sa)tps = tp.String()els := tp.Elem().String()fmt.Printf("string array type is #%s# element type is #%s# length is %d\n", tps, els,tp.Len())输出：string array type is #[3]string# element type is #string# length is 3继续：type st struct &#123; a int b string c map[string]int&#125;st1 := &amp;st&#123; a: 1, b: "abc", c: make(map[string]int),&#125;tp = reflect.TypeOf(st1)tps = tp.String()fmt.Printf("st1 type is #%s#\n", tps)if tp.Kind() == reflect.Ptr &#123; fmt.Printf("st1 type is a pointer\n")&#125;输出：st1 type is #*testreflect.st#st1 type is a pointertestreflect是我的package名，另外注意这里有一个*继续：els = tp.Elem().String()fmt.Printf("st1 element type is #%s#\n", els)输出：st1 element type is #testreflect.st#这里没有*，因为Elem()在指针的时候得到的是原始类型，而不是指针for i := 0; i &lt; tp.Elem().NumField(); i++ &#123; name := tp.Elem().Field(i).Name ktp := tp.Elem().Field(i).Type.String() fmt.Printf("field name is %s, field type is %s\n", name, ktp)&#125;输出：field name is a, field type is intfield name is b, field type is stringfield name is c, field type is map[string]int 小结：Type用来获取和判断 类型相关，甚至可以逐步剖析内部结构。TypeOf返回的是Type类型，Type里保存了这个变量的很多信息，具体需要使用对应的方法取得，如果用错方法会panic，比如不是Map类型，而调用Key(),本来这个方法是返回map的key类型，但是如果变量是string那么调用时就会panic，所以调用前一定要用Kind()判断好。感觉Kind()和switch可能是出现频率最高的。单一通过Type最多可以获得map的field name或是map的key name，无法获得具体值，比如只能知道这个变量是int，具体是多少呢，不知道。接下来Value就是获取具体值的。 Value &amp; VlaueOf 取得一个对象的值，并且还能生成一个同类型的新的对象。 通过一个深度copy函数来理解value是最好的方式了， 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 package testreflectimport ( "reflect")a// DeepCopy ...func DeepCopy(in interface&#123;&#125;) (out interface&#123;&#125;) &#123; tp := reflect.TypeOf(in) val := reflect.ValueOf(in) switch tp.Kind() &#123; case reflect.Array: return CloneArray(in) case reflect.Map: return CloneMap(in) case reflect.Ptr: // case reflect.Slice: return CloneSlice(in) case reflect.Struct: return CloneStruct(in) case reflect.UnsafePointer: // default: tmp := reflect.New(tp).Elem() tmp.Set(val) return tmp.Interface() &#125; return nil&#125;// CloneArray 克隆一个数组，包含length和内容func CloneArray(in interface&#123;&#125;) (out interface&#123;&#125;) &#123; typ := reflect.TypeOf(in) val := reflect.ValueOf(in) length := val.Len() newArray := reflect.New(typ).Elem() for i := 0; i &lt; length; i++ &#123; // 取出原来数组的值 tmp := val.Index(i) tmpVal := reflect.ValueOf(tmp.Interface()) newArray.Index(i).Set(tmpVal) &#125; return newArray.Interface()&#125;// CloneMap 克隆一个Map对象，包含内部数据func CloneMap(in interface&#123;&#125;) (out interface&#123;&#125;) &#123; typ := reflect.TypeOf(in) val := reflect.ValueOf(in) keys := val.MapKeys() newMap := reflect.MakeMap(typ) for _, kv := range keys &#123; tmp := val.MapIndex(kv) ctmp := reflect.ValueOf(DeepCopy(tmp.Interface())) newMap.SetMapIndex(kv, ctmp) &#125; return newMap.Interface()&#125;// CloneSlice 克隆切片对象和内容func CloneSlice(in interface&#123;&#125;) (out interface&#123;&#125;) &#123; typ := reflect.TypeOf(in) val := reflect.ValueOf(in) cap := val.Cap() length := val.Len() newSlice := reflect.MakeSlice(typ, length, cap) for i := 0; i &lt; length; i++ &#123; tmp := val.Index(i) ctmp := reflect.ValueOf(DeepCopy(tmp.Interface())) newSlice.Index(i).Set(ctmp) &#125; return newSlice.Interface()&#125;// CloneStruct 克隆结构体func CloneStruct(in interface&#123;&#125;) interface&#123;&#125; &#123; typ := reflect.TypeOf(in) val := reflect.ValueOf(in) num := typ.Elem().NumField() newStruct := reflect.New(typ).Elem() for i := 0; i &lt; num; i++ &#123; tmp := val.Field(i) ctmp := reflect.ValueOf(DeepCopy(tmp.Interface())) newStruct.Field(i).Set(ctmp) &#125; return newStruct.Interface()&#125; 这其中感觉最重要的就是三个东西，一个是reflect.New 生成一个新的Value对象，类型和传入的一致。 new一个新的对象后要给它赋值，用的是Set(),Set需要的类型是Value，也就是说从另一个对象读出Value，然后new一个新的对象，再把值set进去，就实现了一个简单类型的copy。最后一个是将Value类型转化为interface的 Value.Interface()，返回的是interface{}类型，可以和任何类型进行转化，但是Value是不行的。 TODO：需要继续探索一下，如何可以复制func、chan这种特殊的类型，以及复制的意义是什么]]></content>
      <tags>
        <tag>golang</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[go知识点收集]]></title>
    <url>%2Fgo%E7%9F%A5%E8%AF%86%E7%82%B9%E6%94%B6%E9%9B%86.html</url>
    <content type="text"><![CDATA[使用go中遇到的小问题，记录和回顾用 知识点记录 用切片的指针取值时报错 12 a := &amp;[]int&#123;1,2,3&#125;b := *a[0] // 这里说不能通过指针对应索引的值 其实这时一个优先级的问题，我开始认为的事优先得到 *a然后取对应的0，但是取索引对应的值优先级更高 a[0]，这时就不对了 (*a)[0]这样就OK了]]></content>
  </entry>
  <entry>
    <title><![CDATA[算法200题训练（一）最长递增子序列优化]]></title>
    <url>%2F%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[将最长递增子序列的算法复杂度在原来的基础上优化到O(N*logN) 最长递增子序列优化 上一篇的 最长递增子序列最终实现的时间复杂度为 O(N^2)，现在将要想办法把时间复杂度降到 O(N*logN)，且空间复杂度不变。 上一篇中从代码可以看出两层的for循环，最外层的N是避免不了的，那么里面那层，却存在优化的可能。让我们复习一下里面的那层循环 12345 for j, tmp := range L[:i] &#123; if tmp &lt; item &#123; R[i] = max(R[i], R[j]+1) &#125;&#125; 这层在做什么呢，循环数组i以前的部分，找到比L[i]更小的数，然后去的这些数中最大的那个+1 举例 L=[2,1,6,4,5,2,7,4]，求R[3]的时候 这是后L[3]=4,比L[0]=2、L[1]=1都大，且R[0]和R[1]都等于1，所以R[3]=2。 再深入考虑一下，R[0]和R[1]都是1，那么有必要保存两个吗？如果只保留一个R[0]呢，有什么影响吗？如果只保留一个R[1]有什么影响吗？只保留R[0]不可以，因为当i=5的时候L[5]=2,本来R[5]应该等于2的，这样只能为1了。所以当R中两个数相等的时候只需要保留对应L小的那个，就可以不影响后面的数在这个基础上追加变长，因为有一个小的数保证序列长度了，要一个那么大的数干什么，影响后面的发展啊。 同理， R[2]=3,R[3]=2，那么只保留R[3]就可以了，因为 L[3]=4 &lt; L[2]=6,想象一下，有一个4结尾的长度为2的序列，谁还想得起6结尾同样长度也是2的，因为不管接下来的是5还是7,4结尾的比6结尾的做的都好。 按照这个思路，两个相同的只保留一个，最终得到的R中将不会有重复的数了，R中实际上存储了两个信息，一个是下标i表示 对应到L[i]的数结尾，具体R的值表示的才是子序列长度。 那么个R表的的意思就是：每一个未删除掉的R[i]表示长度为R[i]的子序列中结尾最小的值为L[i]。比如R[5]=2,表示所有长度为2的最小递增子序列中，结尾最小的最小递增子序列的结尾是L[5]=2 这时让我们整理一下R，把那些删除的在最开始就不要插入，同时让i和R[i]的信息对调一下，变成： R[i]表示的是长度为i的最小递增子序列中，结尾最小的那个序列的结尾是R[i] 下面我们来逐步生成一下R,通过遍历L来逐步更新R,注意R的下标不随L遍历同步增加，为了区分下面用R[j]表示,因为数组的下标是从0开始的，所以我们还需要+1表示长度 i=0的时候,只有一个2，所以长度为0+1的子序列的最小结尾为2 i=1,因为1比2小，不能让子序列变长，所以最长递增子序列长度还是1，这时存在两个最长递增子序列，分别是[2]和[1]，长度都是1，但是[1]的结尾比[2]小，所以更新R[0]=1 i=2,L[2] = 6, 这时在R中查找小于6的数(而不是在L中)R中只有一个1，意思是目前只存在一个长度为1的最小递增子序列，且结尾为1，因为6&gt;1，所以一定存在一个长度为2，结尾为6的最小递增子序列。 i=3,L[3]=4，这时还是在R中查找，小于4的值，目前R=[1,6]。1&lt;4, 6&gt;4，所以一定存在一个最长递增子序列的长度为2，结尾为4，这时发现，原来已经存在一个长度为2，结尾为6的，4&lt;6 那么这时更新R将长度为2的最长递增子序列的结尾改为4 i=4,L[4]=5, 因为在R中没有比5大的数，所以一定存在一个更长的递增子序列，且结尾为5。 i=5,L[5]=2, 在R中R[0]=1 2, 所以更新为2，即长度为2的递增子序列，最小结尾为2 i=6,L[6]=7,在R中没有找到比7大的数，最大的是R[2]=5,所以一定存在一个长度为4，结尾为7的递增子序列，R[3]=7, i=7,L[7] = 4,第一个比4大的R值就是R[2]=5,所以更新R[2]=4 最后R值中存在的最后一个数是R[3] = 7，即存在一个长度为3+1=4的递增子序列，且结尾为7 那么每次更新或插入R值时的时间复杂度是多少呢？ 首先我们把上面的过程表达一下： 当L[i]在R中从左到右找到第一个大于等与L[i]的值时，更新R当前下标对应的值为L[i],见：i=1,i=3,i=5,i=7 当L[i]在R中不存在比L[i]大的值时，向R后追加新的值，方式时R的下标+1，填入L[i],见：i=2,i=4,i=6 因为R中的数是递增的，所以在R中查找第一个大于L[i]，或者找不到比L[i]大的数都可以用二分法确认，时间复杂度为O(N*logN) 为什么R中的数是递增的呢？回想一下R的更新和追加新值时的过程，如果这个值特别大，R中没有比它大的，那么这个值会追加在后面，这时保证了有序性，如果这个值找到了一个比它大的值，注意时从左到右的找到第一个比它大的值，那么更新这个值，意思是左边的一定比它小，右边的一定比它大，还是有序的。 代码 ListBetter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273 package LIS// Lis is Longest Increasing Subsequencefunc Lis(L []int) (result int) &#123; if len(L) &lt;= 1 &#123; return len(L) &#125; R := make([]int, len(L)) R[0] = 1 result = 0 for i, item := range L &#123; for j, tmp := range L[:i] &#123; if tmp &lt; item &#123; R[i] = max(R[i], R[j]+1) &#125; &#125; result = max(result, R[i]) &#125; return&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125;// ListBetter 时间复杂度为O(N*logN)的最长递增子序列func ListBetter(L []int) (result int) &#123; if len(L) &lt;= 1 &#123; return len(L) &#125; R := make([]int, len(L)) R[0] = L[0] result = 0 for _, item := range L &#123; index := getIndex(R[:result+1], item) R[index] = item if index &gt; result &#123; result = index &#125; &#125; return result + 1&#125;// 二分查找第一个大于target的数的下标，如果没有比target大的，返回最后一个数的下标+1即切片长度func getIndex(R []int, target int) (index int) &#123; if len(R) &lt;= 0 &#123; return 0 &#125; if R[len(R)-1] &lt; target &#123; return len(R) &#125; start := 0 end := len(R) - 1 i := (start + end) / 2 for ; i &gt; start; i = (start + end) / 2 &#123; if target == R[i] &#123; return i &#125; if target &lt; R[i] &#123; end = i &#125; else &#123; start = i &#125; &#125; if R[start] &gt; target &#123; return start &#125; return end&#125; UT 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 package LISimport ( "testing")func TestLis(t *testing.T) &#123; type args struct &#123; s []int &#125; tests := []struct &#123; name string args args wantResult int &#125;&#123; &#123;name: "empty", args: args&#123;s: []int&#123;&#125;&#125;, wantResult: 0&#125;, &#123;name: "onlyOne", args: args&#123;s: []int&#123;2&#125;&#125;, wantResult: 1&#125;, &#123;name: "none", args: args&#123;s: []int&#123;6, 5, 4, 3, 2, 1&#125;&#125;, wantResult: 1&#125;, &#123;name: "full", args: args&#123;s: []int&#123;1, 2, 3, 4, 5, 6&#125;&#125;, wantResult: 6&#125;, &#123;name: "normal", args: args&#123;s: []int&#123;2, 1, 6, 4, 5, 2, 7, 4&#125;&#125;, wantResult: 4&#125;, &#125; for _, tt := range tests &#123; t.Run(tt.name, func(t *testing.T) &#123; if gotResult := Lis(tt.args.s); gotResult != tt.wantResult &#123; t.Errorf("Lis() = %v, want %v", gotResult, tt.wantResult) &#125; &#125;) &#125;&#125;func TestListBetter(t *testing.T) &#123; type args struct &#123; L []int &#125; tests := []struct &#123; name string args args wantResult int &#125;&#123; &#123;name: "onlyOne", args: args&#123;L: []int&#123;5&#125;&#125;, wantResult: 1&#125;, &#123;name: "two", args: args&#123;L: []int&#123;4, 8&#125;&#125;, wantResult: 2&#125;, &#123;name: "towButOne", args: args&#123;L: []int&#123;7, 6, 5, 4, 3, 2, 1&#125;&#125;, wantResult: 1&#125;, &#123;name: "multiNumbers", args: args&#123;L: []int&#123;2, 1, 6, 4, 5, 2, 7, 4&#125;&#125;, wantResult: 4&#125;, &#123;name: "multiIncreasing", args: args&#123;L: []int&#123;1, 2, 3, 4, 5, 6, 7&#125;&#125;, wantResult: 7&#125;, &#125; for _, tt := range tests &#123; t.Run(tt.name, func(t *testing.T) &#123; if gotResult := ListBetter(tt.args.L); gotResult != tt.wantResult &#123; t.Errorf("ListBetter() = %v, want %v", gotResult, tt.wantResult) &#125; &#125;) &#125;&#125;func Test_getIndex(t *testing.T) &#123; type args struct &#123; R []int target int &#125; tests := []struct &#123; name string args args wantIndex int &#125;&#123; &#123;name: "onlyOneAppend", args: args&#123;R: []int&#123;2&#125;, target: 5&#125;, wantIndex: 1&#125;, &#123;name: "onlyOneReplace", args: args&#123;R: []int&#123;7&#125;, target: 5&#125;, wantIndex: 0&#125;, &#123;name: "multiNumbersFirst", args: args&#123;R: []int&#123;6, 7&#125;, target: 5&#125;, wantIndex: 0&#125;, &#123;name: "multiNumbers", args: args&#123;R: []int&#123;1, 3, 5, 7, 9, 10, 17, 19&#125;, target: 16&#125;, wantIndex: 6&#125;, &#123;name: "multiNumbersLitter", args: args&#123;R: []int&#123;1, 3, 5, 7, 9, 10, 21, 35, 47&#125;, target: 2&#125;, wantIndex: 1&#125;, &#125; for _, tt := range tests &#123; t.Run(tt.name, func(t *testing.T) &#123; if gotIndex := getIndex(tt.args.R, tt.args.target); gotIndex != tt.wantIndex &#123; t.Errorf("getIndex() = %v, want %v", gotIndex, tt.wantIndex) &#125; &#125;) &#125;&#125;]]></content>
      <tags>
        <tag>go</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法200题训练（一）最长递增子序列]]></title>
    <url>%2F%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.html</url>
    <content type="text"><![CDATA[最长递增子序列问题：已知一个序列，包含正数、负数和0，递增子序列指的是，子序列的顺序和已知序列相同，但是不要连续，同时要求后面的数大于前面的数。求最长的子序列的长度 例：已知：&lt;2,1,3,9,4,7,5,2&gt; 最长递增子序列为：&lt;1,3,4,7&gt;或者&lt;1,3,4,5&gt; 答案为 4 最长递增子序列问题 题目 已知一个序列，包含正数、负数和0，递增子序列指的是，子序列的顺序和已知序列相同，但是不要连续，同时要求后面的数大于前面的数。求最长的子序列的长度 例：已知： &lt;2,1,6,4,5,2,7,4&gt; 最长递增子序列为： &lt;2,4,5,7&gt;或者 &lt;1,4,5,7&gt; 答案为 4 解法一： 已知数组为L 设R[i]表示，必须以L[i]结尾的 最长递增子序列 的长度 R[i]计算过程就是求出结果的过程，只要用一个变量记录R中的最大值，就可以得到最终结果 R的计算是这样的，首先R[0] = 1,因为只有一个数的长度为1 然后R[i]的计算是这样的：用L[i]和L[0]到L[i-1]所有数进行比较，如果L[i]更大，那么记下这个数的下标,比如i=3的时候，L[3]=4;其中L[0]、L[1]都小于L[3],取出这些下标0、1，然后在R中查找对应的数值中最大的+1，即MAX(R[0],R[1])+1 =&gt; 2,那么R[3] = 2. 因为R[i]中记录了以L[i]结尾的 最长递增子序列 长度，那么只要某个数大于L[i],那么必然存在一个长度为R[i]+1的 最长递增子序列 ，这个 最长递增子序列 就是以L[i]结尾的那个序列再加上这个新的数。 例： i=0;R[0] = 1,因为必须以L[0]结尾的序列只有 ,长度为1 i=1;比较L[1]和L[0],没有找到比L[1]小的数，那么R[1] = 1,即以L[1]结尾的 最长递增子序列 i=2;用L[2]比较L[0]和L[1],6比1和2都大,然后取R[0]R[1]中最大的值+1，R[2] = Max(R[0],R[1])+1 = 2 i=3;用L[3]比较L[0]~L[2],因为4&lt;6,所以只取0和1下标，R[3] = Max(R[0],R[1])+1 = 2 i=4; 用L[4]比较L[0]~L[3],因为L[4]=5&gt;L[0],5&gt;L[1],5&gt;[3],所以R[4] = Max(R[0],R[1],R[3])+1 = 3 i=5; 用L[5]比较L[0]~L[4], 因为L[5]=2,只有L[5]&gt;L[1], 所以R[5] = R[1] + 1 = 2 i=6,用L[6]比较L[0]~L[5],因为L[6]比前面所有数都大，所以R[6] = Max(R[0]…R[5])+1 = 4 i=7;用L[7]比较L[0]~L[6],L[7]=4&gt;L[0],4&gt;L[1],4&gt;L[5],所以R[7] = Max(R[0],R[1],R[5]) + 1 = 3 len = Max(R[0]…R[7]) = 4 算法复杂度O(N^2),N*N第一个N来自于数组从头到尾的遍历，第二个N来自于每次需要和i以前的对比，取得最大的值+1 len可以每次更新R[i]的时候更新 go代码 123456789101112131415161718192021222324252627 package LIS// Lis is Longest Increasing Subsequencefunc Lis(s []int) (result int) &#123; if len(s) &lt;= 1 &#123; return len(s) &#125; R := make([]int, len(s)) R[0] = 1 result = 0 for i, item := range s &#123; for j, tmp := range s[:i] &#123; if tmp &lt; item &#123; R[i] = max(R[i], R[j]+1) &#125; &#125; result = max(result, R[i]) &#125; return&#125;func max(a, b int) int &#123; if a &gt; b &#123; return a &#125; return b&#125; UT 1234567891011121314151617181920212223242526 package LISimport "testing"func TestLis(t *testing.T) &#123; type args struct &#123; s []int &#125; tests := []struct &#123; name string args args wantResult int &#125;&#123; &#123;name: "empty", args: args&#123;s: []int&#123;&#125;&#125;, wantResult: 0&#125;, &#123;name: "onlyOne", args: args&#123;s: []int&#123;2&#125;&#125;, wantResult: 1&#125;, &#123;name: "full", args: args&#123;s: []int&#123;1, 2, 3, 4, 5, 6&#125;&#125;, wantResult: 6&#125;, &#123;name: "normal", args: args&#123;s: []int&#123;2, 1, 6, 4, 5, 2, 7, 4&#125;&#125;, wantResult: 4&#125;, &#125; for _, tt := range tests &#123; t.Run(tt.name, func(t *testing.T) &#123; if gotResult := Lis(tt.args.s); gotResult != tt.wantResult &#123; t.Errorf("Lis() = %v, want %v", gotResult, tt.wantResult) &#125; &#125;) &#125;&#125; 优化 可以优化的地方在于计算R[i]的时候，可以让L[i]和前面的数比较加速，因为如果R[j]和R[k] 都等于M，且j&lt;k,那么只要L[i]只要和L[j]比较就可以了，而且R[j]和R[k]只要保存一个就可以了。下期完整介绍算法复杂度为 O(N*logN)的最长递增子序列]]></content>
      <tags>
        <tag>go</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法200题训练]]></title>
    <url>%2F%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83.html</url>
    <content type="text"><![CDATA[算法200题训练 加强算法概念和算法思考方式，向左老师学习，先练200题，中间适当穿插理论知识学习 目前思路： 每周两题，以见过的，且有完整分析的经典问题为主 20题后开始按系统查找算法题，集中突击不同类型算题，如二叉树，字符串匹配等，以经典问题为主。 每10题左右增加一篇总结和回顾]]></content>
      <tags>
        <tag>日常</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nsq源码学习笔记（一）----nsqd启动]]></title>
    <url>%2FNsq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89----nsqd%E5%90%AF%E5%8A%A8.html</url>
    <content type="text"><![CDATA[nsqd启动代码学习 版本：1.0.1-alpha 入口 nsqd的入口代码位于： $GOPATH//github.com/nsqio/nsq/apps/nsqd/nsqd.go nsqd代码在 $GOPATH//github.com/nsqio/nsq/nsqd main函数 入口函数就是 main main 一共4行，run一个 program.Start直到收到结束信息（Control+C或是kill） 1234 prg := &amp;program&#123;&#125;if err := svc.Run(prg, syscall.SIGINT, syscall.SIGTERM); err != nil &#123; log.Fatal(err)&#125; 启动过程 program.Start 就是启动的主要内容分别如下： 解析参数，存入opts 通过opts new一个nsqd 加载数据，指的是从本地文件加载topic和topic的channel 保存数据回本地文件 进入nsqd.Main 参数解析 参数解析使用的是go自带的 flag包，解析 nsqd --help中参数，其中 options.Resolve(opts, flagSet, cfg)作用还不能确定，稍后补上 通过opts new一个nsqd 如果通过options创建一个nsqd，首先看一下nsqd结构 12345678910111213141516171819202122232425262728293031 type NSQD struct &#123; // 64bit atomic vars need to be first for proper alignment on 32bit platforms clientIDSequence int64 sync.RWMutex opts atomic.Value dl *dirlock.DirLock // 本地数据文件目录的锁 isLoading int32 // 是否处于加载本地数据过程中 errValue atomic.Value startTime time.Time // 启动时间 topicMap map[string]*Topic // 所有topic存储在这里 lookupPeers atomic.Value tcpListener net.Listener httpListener net.Listener httpsListener net.Listener tlsConfig *tls.Config // tls配置信息 poolSize int notifyChan chan interface&#123;&#125; optsNotificationChan chan struct&#123;&#125; exitChan chan int // 退出信号 waitGroup util.WaitGroupWrapper ci *clusterinfo.ClusterInfo&#125; 结构中每个属性的意义和作用，随着创建和启动逐步完善 创建nsqd实例前先做了两件事： 首先检查了是否指定了 data-path，如果没有使用当前目录，为什么创建实例前一定要确定目录，稍后提到 给options创建了一个Logger，为什么不是给nsqd增加Logger而是给了options，还有怎么使用，稍后需要注意一下。(填坑：nsqd专门创建logger函数，内部使用的就是options.Logger，对外的实现是n.logf) 创建实例，nsqd没有一次创建所有属性 12345678 n := &amp;NSQD&#123; startTime: time.Now(), // 当前时间，也就是启动时间 topicMap: make(map[string]*Topic), // 这个很关键了，需要下次专门介绍，用于保存所有topic的结构 exitChan: make(chan int), // 退出信号 notifyChan: make(chan interface&#123;&#125;), // 还不知道，稍后填坑 optsNotificationChan: make(chan struct&#123;&#125;, 1), // 不知道，稍后填坑 dl: dirlock.New(dataPath), // 上面提到的数据目录，为了防止多个进程使用同一个目录，需要对目录加锁，稍后详细提到&#125; 初始化http api client n.ci = clusterinfo.New(n.logf, httpcli),同时日志输出保持一致 指定日志输出等级 opts.logLevel, err = lg.ParseLogLevel(opts.LogLevel, opts.Verbose) 给数据目录上锁，应该是独占锁，保证其他进程不能在上锁，Ulock动作在Exit才执行，也就是说整个进程执行期间，都是锁住的 接下来是一些参数检查，和tls配置检查 然后返回整个nsqd的实例 加载本地数据 nsqd.LoadMetadata()从本地文件加载数据 文件加载过程专门使用atomic标示加载过程 12 atomic.StoreInt32(&amp;n.isLoading, 1)defer atomic.StoreInt32(&amp;n.isLoading, 0) 应该是为了兼容老的版本，加载的时候需要加载两个文件，其中一个包含ID信息是老版本的文件，读取两个文件后进行比对，如果不一致，返回错误，要求删除其中一个。如果只有一个文件，则只加载该文件的数据，数据的格式是json,内容是这个样子 123456789101112131415 &#123; "topics": [ &#123; "channels": [ &#123; "name": "ch1", "paused": false &#125; ], "name": "tp1", "paused": false &#125; ], "version": "1.0.1-alpha"&#125; 保存数据回本地文件 topics在每次创建/删除是都会同步到文件，添加或删除channels也会同步到文件，使用的的方法就是 PersistMetadata,以后这详细介绍如何触发保存到文件动作，这里只是简单介绍一下保存过程中主要做了哪些事 主要分为两个部分 嵌套循环topic 和 topic内的channel，写入文件 通过创建tmp文件，在rename方式写入数据，然后再创建一个软连接 第一个部分是获取元数据 遍历nsq.topicMap, topicMap是目前我认为最重要的结构，主要的数据都保存在这个结构中。遍历topicMap中的每一个topic，只取出topic的name和paused两个属性值保存下来，然后便利topic.channelMap同样只取出name和paused连个属性，在这两层循环中都判断了是否是临时的，ephemeral这个以后还会见到很多次，topic或是channel的name中带有 #ephemeral都被认为是临时的，不会读取，也不会保存。取出所有topic和channel后序列化成json保存入临时文件。 临时文件和软连接 写临时文件然后在rename到真正要保存的文件名，这个属于标准流程，肯定不能直接写目标文件，万一出错或发生意外避免影响到源文件/目标文件，写入成功后在rename安全多了。 为什么创建软连接，其实上面加载过程中加载的两个文件就来源于这里，如果是软连接，读出来的内容自然一样，看来还是为了兼容以前的版本。 做完上面的事，就要进入真正的启动和监听部分 nsq.Main]]></content>
      <tags>
        <tag>go</tag>
        <tag>Nsq</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇怪的问题记录]]></title>
    <url>%2F%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[一些在工作中遇到的奇怪问题的记录，方便回忆查找 Mac OS X 下目录名大小写不敏感问题 在Terminal里， cd 命令可以进入一个忽略大小写的目录，比如我有一个目录， ~/Go,我可以 cd ~/Go,也可以 cd ~/go，实际上这两个命令进入的是同一个目录。进而发现Mac默认文件和目录是不区分大小写的（这个有点反*inux），但是多数程序是关系区分大小写的。所以就出现问题了。 在一个Nsq的项目里使用的vendor作依赖管理，用dep也已经下载好了，但是test通不过，build也不行，说找不到package，而且从错误信息上看，只搜索了GOPATH和GOROOT，检查vendor目录，依赖包都在，怎么也找不到原因，最后猜测可能和目录大小写有关，因为之前是 cd go而目录名是Go，这次 cd Go然后逐层进入，再次test，果然好了 总结：OS X 默认不区分大小写，在Terminal使用的时候要注意目录名称，或者统一使用小写避免问题，另外可以新建一个大小写敏感的分区 OS X 中设置大小写敏感的分区并切换]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac下使用dokcer搭建开发环境记录]]></title>
    <url>%2FMac%E4%B8%8B%E4%BD%BF%E7%94%A8dokcer%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95.html</url>
    <content type="text"><![CDATA[搭建环境中一些知识点的记录，帮助自己回忆一些遇到的问题 背景 工作内容包含多个项目，对应语言为php，不同项目独立维护，通过不同的域名接入，系统之间通过http交换信息。目标是实现一个一键式脚本，搭建一个开发环境可以同时支持多个项目运行，其实就是Nginx+php-fpm的docker+git checkout代码，然后 docker-compose一起管理。 有两个注意点 多个项目同时存在，需要通过域名区分每个项目的入口地址 多个项目在不同的git项目上，最好能一次性准备好 阿里云的docker源 为了解决docker pull 的问题优先使用的是 阿里云的仓库，在上面找的nginx和php-fpm，需要注意的是上面的发布的image不一定都是好用的，pull之后检查一下是否符合需求。 build自己的image 制作这个一键式脚本最花费时间的地方是，想要重新build一个image，默认包含nginx的配置。不同域名对应不同的项目，一个docker通过nginx配置同时支持多个项目。当然配置域名后要在本地修改hosts文件才能正常访问。制作image就需要写一个Dockerfile，目的就是copy一些 nginx_xxx.conf的配置文件进去，其他的信息不用修改。在这里学到了两个知识点： 使用 doker inspect [image_id]可以查看某个镜像的当前设置，包含 CMD Volumes EXPOSE等，如下图 在基于原来的image制作新的时，只需要设置需要修改的部分即可，不需要每个Dokcerfile都填写完全的信息，比如我这个需求就是添加一些配置文件，那么Dockerfile就可以只有 FROM和 COPY docker-compose关联多个docker 制作工程中还有一个点学习到的就是docker-compose.yml中可以通过links方便的的吧两个docker连通，这个词可能不准确，我的理解是可能互相认识，可以通过名字访问到对方 mysql密码问题 运行mysql的docker时，需要指定一个重要的环境变量 MYSQL_ROOT_PASSWORD，最好加上 MYSQL_ROOT_HOST=%，但是好多地方都没有说明挂载data的问题，自己就遇到了设置了 MYSQL_ROOT_PASSWORD但是连接失败的问题，原因就在挂载 /var/lib/msyql这个目录的时候里面有上次运行的文件，导致没能将新的密码设置进去。简单的方法就是第一次启动前确认挂载的目录是空的，保证这次启动时完全初始化的。 sudo 和重定向问题 在制作一键式脚本时，因为要更新hosts文件，需要执行类似 sudo echo &quot;$hosts_conf&quot; &gt;&gt;/etc/hosts 一直提示 Permission denied，感觉sudo没起作用，实际上是sudo只授权给了 echo而重定向 &gt;&gt;也需要sudo权限，搜索结果y sudo sh -c &quot;echo \&quot;$host_config\&quot; &gt;&gt; /etc/hostscd &quot; 感觉上有点像eval的样子，将所有动作都包含在一起了 sed替换路径问题 sed替换字符串中的某些特定字符很简单 sed &quot;s/abc/ABC/g&quot; filename.txt 使用变量的话 sed &quot;s/$src/$dst/g&quot; filename.txt 但是如果变量中带有 /就又问题，一个方法是保证变量内的 /被替换为 \/转义后在传进来，不过还有一个更好的办法 sed &quot;s#$src#$dst#g&quot; 这样 /就不需要转义了 host问题 由于多个php项目都在同一个挂载目录，同时不同项目使用了不同的域名，且不同项目见接口调用使用了域名进行访问。一开始只有本机配置了hosts文件，保证本地访问时可以通过127.0.0.1 访问正常，但是遇到项目间接口调用的时候出现了Connection Refuse。原因是php-fpm docker内查找域名的时候没有找到，所以通过本机得到了域名指向的是127.0.0.1，于是访问本地，然后出错了，因为对于本机来说127.0.0.1已经和docker做了端口映射，但是php-fpm内部访问的自己内部的端口，需要让php-fpm访问nginx的端口就对了。最近解决方法是给每个容器指定ip，且给php-fpm增加host配置 1234567891011121314 ... networks: finance-network: ipv4_address: 172.28.0.10 extra_hosts: - "dev.xxx.xxx.com:172.28.0.11"...networks: finance-network: driver: bridge ipam: driver: default config: - subnet: 172.28.0.0/24]]></content>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记博客开坑]]></title>
    <url>%2F%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%9D%91.html</url>
    <content type="text"><![CDATA[列举一下接下来要开坑的分类 开坑分类 日常吐槽 经验总结 算法学习 go 源码和源码包学习 开源项目和源码学习 自己的项目]]></content>
      <tags>
        <tag>日常</tag>
      </tags>
  </entry>
</search>
