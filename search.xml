<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>算法200题训练（一）最长递增子序列优化</title>
      <link href="/2018/07/02/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/02/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>将最长递增子序列的算法复杂度在原来的基础上优化到O(N*logN)  <br>  <a id="more"></a></p><h3 id="最长递增子序列优化">  <a href="#最长递增子序列优化" class="headerlink" title="最长递增子序列优化"></a>最长递增子序列优化</h3><p>上一篇的  <a href="https://blog.whyming.com/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/" target="_blank" rel="noopener">最长递增子序列</a>最终实现的时间复杂度为  <strong>O(N^2)</strong>，现在将要想办法把时间复杂度降到  <strong>O(N*logN)</strong>，且空间复杂度不变。</p><p>上一篇中从代码可以看出两层的for循环，最外层的N是避免不了的，那么里面那层，却存在优化的可能。让我们复习一下里面的那层循环</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">for</span> j, tmp := <span class="keyword">range</span> L[:i] &#123;</span><br><span class="line"><span class="keyword">if</span> tmp &lt; item &#123;</span><br><span class="line">R[i] = max(R[i], R[j]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>这层在做什么呢，循环数组i以前的部分，找到比L[i]更小的数，然后去的这些数中最大的那个+1</p><p>举例  <code>L=[2,1,6,4,5,2,7,4]</code>，求R[3]的时候</p><p>  <img src="https://blog.whyming.com/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/R2.svg" alt="R3"></p><p>这是后L[3]=4,比L[0]=2、L[1]=1都大，且R[0]和R[1]都等于1，所以R[3]=2。  <br>再深入考虑一下，R[0]和R[1]都是1，那么有必要保存两个吗？如果只保留一个R[0]呢，有什么影响吗？如果只保留一个R[1]有什么影响吗？只保留R[0]不可以，因为当i=5的时候L[5]=2,本来R[5]应该等于2的，这样只能为1了。所以当R中两个数相等的时候只需要保留对应L小的那个，就可以不影响后面的数在这个基础上追加变长，因为有一个小的数保证序列长度了，要一个那么大的数干什么，影响后面的发展啊。</p><p>同理，  <code>R[2]=3,R[3]=2</code>，那么只保留R[3]就可以了，因为  <code>L[3]=4 &lt; L[2]=6</code>,想象一下，有一个4结尾的长度为2的序列，谁还想得起6结尾同样长度也是2的，因为不管接下来的是5还是7,4结尾的比6结尾的做的都好。</p><p>按照这个思路，两个相同的只保留一个，最终得到的R中将不会有重复的数了，R中实际上存储了两个信息，一个是下标i表示  <strong>对应到L[i]的数结尾</strong>，具体R的值表示的才是子序列长度。 那么个R表的的意思就是：每一个未删除掉的R[i]表示长度为R[i]的子序列中结尾最小的值为L[i]。比如R[5]=2,表示所有长度为2的最小递增子序列中，结尾最小的最小递增子序列的结尾是L[5]=2</p><p>这时让我们整理一下R，把那些删除的在最开始就不要插入，同时让i和R[i]的信息对调一下，变成：  <strong>R[i]表示的是长度为i的最小递增子序列中，结尾最小的那个序列的结尾是R[i]</strong></p><p>下面我们来逐步生成一下R,通过遍历L来逐步更新R,注意R的下标不随L遍历同步增加，为了区分下面用R[j]表示,因为数组的下标是从0开始的，所以我们还需要+1表示长度  <br>i=0的时候,只有一个2，所以长度为0+1的子序列的最小结尾为2  <br>  <img src="./R0.svg" alt="R0"></p><p>i=1,因为1比2小，不能让子序列变长，所以最长递增子序列长度还是1，这时存在两个最长递增子序列，分别是[2]和[1]，长度都是1，但是[1]的结尾比[2]小，所以更新R[0]=1  <br>  <img src="./R1.svg" alt="R1"></p><p>i=2,L[2] = 6, 这时在R中查找小于6的数(而不是在L中)R中只有一个1，意思是目前只存在一个长度为1的最小递增子序列，且结尾为1，因为6&gt;1，所以一定存在一个长度为2，结尾为6的最小递增子序列。  <br>  <img src="./R2.svg" alt="R2"></p><p>i=3,L[3]=4，这时还是在R中查找，小于4的值，目前R=[1,6]。1&lt;4, 6&gt;4，所以一定存在一个最长递增子序列的长度为2，结尾为4，这时发现，原来已经存在一个长度为2，结尾为6的，4&lt;6  那么这时更新R将长度为2的最长递增子序列的结尾改为4  <br>  <img src="./R3.svg" alt="R3"></p><p>i=4,L[4]=5, 因为在R中没有比5大的数，所以一定存在一个更长的递增子序列，且结尾为5。  <br>  <img src="./R4.svg" alt="R4"></p><p>i=5,L[5]=2, 在R中R[0]=1  <2 ,r[1]="4">2, 所以更新为2，即长度为2的递增子序列，最小结尾为2    <br>    <img src="./R5.svg" alt="R5"></2></p><p>i=6,L[6]=7,在R中没有找到比7大的数，最大的是R[2]=5,所以一定存在一个长度为4，结尾为7的递增子序列，R[3]=7,  <br>  <img src="./R6.svg" alt="R6"></p><p>i=7,L[7] = 4,第一个比4大的R值就是R[2]=5,所以更新R[2]=4  <br>  <img src="./R7.svg" alt="R7"></p><p>最后R值中存在的最后一个数是R[3] = 7，即存在一个长度为3+1=4的递增子序列，且结尾为7</p><p>那么每次更新或插入R值时的时间复杂度是多少呢？  <br>首先我们把上面的过程表达一下：</p><ul>  <li>当L[i]在R中从左到右找到第一个大于等与L[i]的值时，更新R当前下标对应的值为L[i],见：i=1,i=3,i=5,i=7</li>  <li>当L[i]在R中不存在比L[i]大的值时，向R后追加新的值，方式时R的下标+1，填入L[i],见：i=2,i=4,i=6</li></ul><p>因为R中的数是递增的，所以在R中查找第一个大于L[i]，或者找不到比L[i]大的数都可以用二分法确认，时间复杂度为O(N*logN)</p><p>为什么R中的数是递增的呢？回想一下R的更新和追加新值时的过程，如果这个值特别大，R中没有比它大的，那么这个值会追加在后面，这时保证了有序性，如果这个值找到了一个比它大的值，注意时从左到右的找到第一个比它大的值，那么更新这个值，意思是左边的一定比它小，右边的一定比它大，还是有序的。</p><h4 id="代码-ListBetter">  <a href="#代码-ListBetter" class="headerlink" title="代码 ListBetter"></a>代码 ListBetter</h4><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> LIS</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lis is Longest Increasing Subsequence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lis</span><span class="params">(L []<span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(L) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(L)</span><br><span class="line">&#125;</span><br><span class="line">R := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(L))</span><br><span class="line">R[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, item := <span class="keyword">range</span> L &#123;</span><br><span class="line"><span class="keyword">for</span> j, tmp := <span class="keyword">range</span> L[:i] &#123;</span><br><span class="line"><span class="keyword">if</span> tmp &lt; item &#123;</span><br><span class="line">R[i] = max(R[i], R[j]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = max(result, R[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListBetter 时间复杂度为O(N*logN)的最长递增子序列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListBetter</span><span class="params">(L []<span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(L) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(L)</span><br><span class="line">&#125;</span><br><span class="line">R := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(L))</span><br><span class="line">R[<span class="number">0</span>] = L[<span class="number">0</span>]</span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> L &#123;</span><br><span class="line">index := getIndex(R[:result+<span class="number">1</span>], item)</span><br><span class="line">R[index] = item</span><br><span class="line"><span class="keyword">if</span> index &gt; result &#123;</span><br><span class="line">result = index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找第一个大于target的数的下标，如果没有比target大的，返回最后一个数的下标+1即切片长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIndex</span><span class="params">(R []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(R) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> R[<span class="built_in">len</span>(R)<span class="number">-1</span>] &lt; target &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(R)</span><br><span class="line">&#125;</span><br><span class="line">start := <span class="number">0</span></span><br><span class="line">end := <span class="built_in">len</span>(R) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i := (start + end) / <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> ; i &gt; start; i = (start + end) / <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">if</span> target == R[i] &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> target &lt; R[i] &#123;</span><br><span class="line">end = i</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">start = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> R[start] &gt; target &#123;</span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> end</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="UT">  <a href="#UT" class="headerlink" title="UT"></a>UT</h4><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> LIS</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLis</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">s []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name       <span class="keyword">string</span></span><br><span class="line">args       args</span><br><span class="line">wantResult <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">"empty"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;&#125;&#125;, wantResult: <span class="number">0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"onlyOne"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">2</span>&#125;&#125;, wantResult: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"none"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;, wantResult: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"full"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;, wantResult: <span class="number">6</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"normal"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>&#125;&#125;, wantResult: <span class="number">4</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> gotResult := Lis(tt.args.s); gotResult != tt.wantResult &#123;</span><br><span class="line">t.Errorf(<span class="string">"Lis() = %v, want %v"</span>, gotResult, tt.wantResult)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestListBetter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">L []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name       <span class="keyword">string</span></span><br><span class="line">args       args</span><br><span class="line">wantResult <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">"onlyOne"</span>, args: args&#123;L: []<span class="keyword">int</span>&#123;<span class="number">5</span>&#125;&#125;, wantResult: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"two"</span>, args: args&#123;L: []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">8</span>&#125;&#125;, wantResult: <span class="number">2</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"towButOne"</span>, args: args&#123;L: []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;, wantResult: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"multiNumbers"</span>, args: args&#123;L: []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>&#125;&#125;, wantResult: <span class="number">4</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"multiIncreasing"</span>, args: args&#123;L: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;&#125;, wantResult: <span class="number">7</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> gotResult := ListBetter(tt.args.L); gotResult != tt.wantResult &#123;</span><br><span class="line">t.Errorf(<span class="string">"ListBetter() = %v, want %v"</span>, gotResult, tt.wantResult)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_getIndex</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">R      []<span class="keyword">int</span></span><br><span class="line">target <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name      <span class="keyword">string</span></span><br><span class="line">args      args</span><br><span class="line">wantIndex <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">"onlyOneAppend"</span>, args: args&#123;R: []<span class="keyword">int</span>&#123;<span class="number">2</span>&#125;, target: <span class="number">5</span>&#125;, wantIndex: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"onlyOneReplace"</span>, args: args&#123;R: []<span class="keyword">int</span>&#123;<span class="number">7</span>&#125;, target: <span class="number">5</span>&#125;, wantIndex: <span class="number">0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"multiNumbersFirst"</span>, args: args&#123;R: []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>&#125;, target: <span class="number">5</span>&#125;, wantIndex: <span class="number">0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"multiNumbers"</span>, args: args&#123;R: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">19</span>&#125;, target: <span class="number">16</span>&#125;, wantIndex: <span class="number">6</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"multiNumbersLitter"</span>, args: args&#123;R: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">47</span>&#125;, target: <span class="number">2</span>&#125;, wantIndex: <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> gotIndex := getIndex(tt.args.R, tt.args.target); gotIndex != tt.wantIndex &#123;</span><br><span class="line">t.Errorf(<span class="string">"getIndex() = %v, want %v"</span>, gotIndex, tt.wantIndex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法200题训练（一）最长递增子序列</title>
      <link href="/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>最长递增子序列问题：已知一个序列，包含正数、负数和0，递增子序列指的是，子序列的顺序和已知序列相同，但是不要连续，同时要求后面的数大于前面的数。求最长的子序列的长度  <br>例：已知：&lt;2,1,3,9,4,7,5,2&gt;  <br>最长递增子序列为：&lt;1,3,4,7&gt;或者&lt;1,3,4,5&gt;  <br>答案为 4  <br>  <a id="more"></a></p><h2 id="最长递增子序列问题">  <a href="#最长递增子序列问题" class="headerlink" title="最长递增子序列问题"></a>最长递增子序列问题</h2><h3 id="题目">  <a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>已知一个序列，包含正数、负数和0，递增子序列指的是，子序列的顺序和已知序列相同，但是不要连续，同时要求后面的数大于前面的数。求最长的子序列的长度</p><p>例：已知：  <code>&lt;2,1,6,4,5,2,7,4&gt;</code></p><p>最长递增子序列为：  <code>&lt;2,4,5,7&gt;</code>或者  <code>&lt;1,4,5,7&gt;</code></p><p>答案为  <code>4</code></p><h3 id="解法一：">  <a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>已知数组为L  <br>设R[i]表示，必须以L[i]结尾的  <strong>    <code>最长递增子序列</code>  </strong>的长度</p><p>R[i]计算过程就是求出结果的过程，只要用一个变量记录R中的最大值，就可以得到最终结果</p><p>R的计算是这样的，首先R[0] = 1,因为只有一个数的长度为1</p><p>然后R[i]的计算是这样的：用L[i]和L[0]到L[i-1]所有数进行比较，如果L[i]更大，那么记下这个数的下标,比如i=3的时候，L[3]=4;其中L[0]、L[1]都小于L[3],取出这些下标0、1，然后在R中查找对应的数值中最大的+1，即MAX(R[0],R[1])+1  =&gt; 2,那么R[3] = 2. </p><p>因为R[i]中记录了以L[i]结尾的  <strong>    <code>最长递增子序列</code>  </strong>长度，那么只要某个数大于L[i],那么必然存在一个长度为R[i]+1的  <strong>    <code>最长递增子序列</code>  </strong>，这个  <strong>    <code>最长递增子序列</code>  </strong>就是以L[i]结尾的那个序列再加上这个新的数。</p><p>例：  <br>  <img src="./origin_list.svg" alt="L"></p><p>i=0;R[0] = 1,因为必须以L[0]结尾的序列只有  <2>,长度为1    <br>    <img src="./R0.svg" alt="R0"></2></p><p>i=1;比较L[1]和L[0],没有找到比L[1]小的数，那么R[1] = 1,即以L[1]结尾的  <strong>    <code>最长递增子序列</code>  </strong>  <br>  <img src="./R1.svg" alt="R1"></p><p>i=2;用L[2]比较L[0]和L[1],6比1和2都大,然后取R[0]R[1]中最大的值+1，R[2] = Max(R[0],R[1])+1 = 2  <br>  <img src="./R2.svg" alt="R2"></p><p>i=3;用L[3]比较L[0]~L[2],因为4&lt;6,所以只取0和1下标，R[3] = Max(R[0],R[1])+1 = 2  <br>  <img src="./R3.svg" alt="R3"></p><p>i=4; 用L[4]比较L[0]~L[3],因为L[4]=5&gt;L[0],5&gt;L[1],5&gt;[3],所以R[4] = Max(R[0],R[1],R[3])+1  = 3  <br>  <img src="./R4.svg" alt="R4"></p><p>i=5; 用L[5]比较L[0]~L[4], 因为L[5]=2,只有L[5]&gt;L[1], 所以R[5] = R[1] + 1 = 2  <br>  <img src="./R5.svg" alt="R5"></p><p>i=6,用L[6]比较L[0]~L[5],因为L[6]比前面所有数都大，所以R[6] = Max(R[0]…R[5])+1 = 4  <br>  <img src="R6.svg" alt="R6"></p><p>i=7;用L[7]比较L[0]~L[6],L[7]=4&gt;L[0],4&gt;L[1],4&gt;L[5],所以R[7] = Max(R[0],R[1],R[5])  + 1 = 3  <br>  <img src="R6.svg" alt="R7"></p><p>len = Max(R[0]…R[7]) = 4</p><p>算法复杂度O(N^2),N*N第一个N来自于数组从头到尾的遍历，第二个N来自于每次需要和i以前的对比，取得最大的值+1  <br>len可以每次更新R[i]的时候更新</p><h3 id="go代码">  <a href="#go代码" class="headerlink" title="go代码"></a>go代码</h3><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> LIS</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lis is Longest Increasing Subsequence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lis</span><span class="params">(s []<span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line">R := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">R[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, item := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">for</span> j, tmp := <span class="keyword">range</span> s[:i] &#123;</span><br><span class="line"><span class="keyword">if</span> tmp &lt; item &#123;</span><br><span class="line">R[i] = max(R[i], R[j]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = max(result, R[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>UT</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> LIS</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLis</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">s []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name       <span class="keyword">string</span></span><br><span class="line">args       args</span><br><span class="line">wantResult <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">"empty"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;&#125;&#125;, wantResult: <span class="number">0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"onlyOne"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">2</span>&#125;&#125;, wantResult: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"full"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;, wantResult: <span class="number">6</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"normal"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>&#125;&#125;, wantResult: <span class="number">4</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> gotResult := Lis(tt.args.s); gotResult != tt.wantResult &#123;</span><br><span class="line">t.Errorf(<span class="string">"Lis() = %v, want %v"</span>, gotResult, tt.wantResult)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="优化">  <a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>可以优化的地方在于计算R[i]的时候，可以让L[i]和前面的数比较加速，因为如果R[j]和R[k] 都等于M，且j&lt;k,那么只要L[i]只要和L[j]比较就可以了，而且R[j]和R[k]只要保存一个就可以了。下期完整介绍算法复杂度为  <strong>O(N*logN)</strong>的最长递增子序列</p>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法200题训练</title>
      <link href="/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83/"/>
      <url>/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83/</url>
      <content type="html"><![CDATA[<h2 id="算法200题训练">  <a href="#算法200题训练" class="headerlink" title="算法200题训练"></a>算法200题训练</h2><p>加强算法概念和算法思考方式，向左老师学习，先练200题，中间适当穿插理论知识学习</p><p>目前思路：</p><ul>  <li>每周两题，以见过的，且有完整分析的经典问题为主</li>  <li>20题后开始按系统查找算法题，集中突击不同类型算题，如二叉树，字符串匹配等，以经典问题为主。</li>  <li>每10题左右增加一篇总结和回顾</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nsq源码学习笔记（一）----nsqd启动</title>
      <link href="/2018/06/08/Nsq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89----nsqd%E5%90%AF%E5%8A%A8/"/>
      <url>/2018/06/08/Nsq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89----nsqd%E5%90%AF%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>nsqd启动代码学习  <br>  <a id="more"></a></p><h4 id="版本：1-0-1-alpha">  <a href="#版本：1-0-1-alpha" class="headerlink" title="版本：1.0.1-alpha"></a>版本：1.0.1-alpha</h4><h3 id="入口">  <a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>nsqd的入口代码位于：  <code>$GOPATH//github.com/nsqio/nsq/apps/nsqd/nsqd.go</code></p><p>nsqd代码在  <code>$GOPATH//github.com/nsqio/nsq/nsqd</code></p><h3 id="main函数">  <a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>入口函数就是  <code>main</code></p><p>  <code>main</code> 一共4行，run一个  <code>program.Start</code>直到收到结束信息（Control+C或是kill）</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">prg := &amp;program&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := svc.Run(prg, syscall.SIGINT, syscall.SIGTERM); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="启动过程">  <a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>  <code>program.Start</code> 就是启动的主要内容分别如下：</p><ul>  <li>(解析参数，存入opts)[    <a href="http://aaaaa#参数解析]" target="_blank" rel="noopener">http://aaaaa#参数解析]</a>  </li>  <li>通过opts new一个nsqd</li>  <li>加载数据，指的是从本地文件加载topic和topic的channel</li>  <li>保存数据回本地文件</li>  <li>进入nsqd.Main</li></ul><h4 id="参数解析">  <a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>参数解析使用的是go自带的  <code>flag</code>包，解析  <code>nsqd --help</code>中参数，其中  <code>options.Resolve(opts, flagSet, cfg)</code>作用还不能确定，稍后补上</p><h4 id="通过opts-new一个nsqd">  <a href="#通过opts-new一个nsqd" class="headerlink" title="通过opts new一个nsqd"></a>通过opts new一个nsqd</h4><p>如果通过options创建一个nsqd，首先看一下nsqd结构</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">type</span> NSQD <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 64bit atomic vars need to be first for proper alignment on 32bit platforms</span></span><br><span class="line">clientIDSequence <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">sync.RWMutex</span><br><span class="line"></span><br><span class="line">opts atomic.Value</span><br><span class="line"></span><br><span class="line">dl        *dirlock.DirLock <span class="comment">// 本地数据文件目录的锁</span></span><br><span class="line">isLoading <span class="keyword">int32</span> <span class="comment">// 是否处于加载本地数据过程中</span></span><br><span class="line">errValue  atomic.Value</span><br><span class="line">startTime time.Time <span class="comment">// 启动时间</span></span><br><span class="line"></span><br><span class="line">topicMap <span class="keyword">map</span>[<span class="keyword">string</span>]*Topic <span class="comment">// 所有topic存储在这里</span></span><br><span class="line"></span><br><span class="line">lookupPeers atomic.Value</span><br><span class="line"></span><br><span class="line">tcpListener   net.Listener</span><br><span class="line">httpListener  net.Listener</span><br><span class="line">httpsListener net.Listener</span><br><span class="line">tlsConfig     *tls.Config <span class="comment">// tls配置信息</span></span><br><span class="line"></span><br><span class="line">poolSize <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">notifyChan           <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">optsNotificationChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">exitChan             <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 退出信号</span></span><br><span class="line">waitGroup            util.WaitGroupWrapper</span><br><span class="line"></span><br><span class="line">ci *clusterinfo.ClusterInfo</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>结构中每个属性的意义和作用，随着创建和启动逐步完善  <br>创建nsqd实例前先做了两件事：</p><ul>  <li>首先检查了是否指定了    <code>data-path</code>，如果没有使用当前目录，为什么创建实例前一定要确定目录，稍后提到</li>  <li>给options创建了一个Logger，为什么不是给nsqd增加Logger而是给了options，还有怎么使用，稍后需要注意一下。(填坑：nsqd专门创建logger函数，内部使用的就是options.Logger，对外的实现是n.logf)</li></ul><p>创建实例，nsqd没有一次创建所有属性</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">n := &amp;NSQD&#123;</span><br><span class="line">startTime:            time.Now(), <span class="comment">// 当前时间，也就是启动时间</span></span><br><span class="line">topicMap:             <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Topic), <span class="comment">// 这个很关键了，需要下次专门介绍，用于保存所有topic的结构</span></span><br><span class="line">exitChan:             <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="comment">// 退出信号</span></span><br><span class="line">notifyChan:           <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;), <span class="comment">// 还不知道，稍后填坑</span></span><br><span class="line">optsNotificationChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>), <span class="comment">// 不知道，稍后填坑</span></span><br><span class="line">dl:                   dirlock.New(dataPath), <span class="comment">// 上面提到的数据目录，为了防止多个进程使用同一个目录，需要对目录加锁，稍后详细提到</span></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>初始化http api client  <code>n.ci = clusterinfo.New(n.logf, httpcli)</code>,同时日志输出保持一致</p><p>指定日志输出等级  <code>opts.logLevel, err = lg.ParseLogLevel(opts.LogLevel, opts.Verbose)</code></p><p>给数据目录上锁，应该是独占锁，保证其他进程不能在上锁，Ulock动作在Exit才执行，也就是说整个进程执行期间，都是锁住的</p><p>接下来是一些参数检查，和tls配置检查  <br>然后返回整个nsqd的实例</p><h4 id="加载本地数据">  <a href="#加载本地数据" class="headerlink" title="加载本地数据"></a>加载本地数据</h4><p>  <code>nsqd.LoadMetadata()</code>从本地文件加载数据  <br>文件加载过程专门使用atomic标示加载过程</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">atomic.StoreInt32(&amp;n.isLoading, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> atomic.StoreInt32(&amp;n.isLoading, <span class="number">0</span>)</span><br></pre>      </td>    </tr>  </table></figure><p>应该是为了兼容老的版本，加载的时候需要加载两个文件，其中一个包含ID信息是老版本的文件，读取两个文件后进行比对，如果不一致，返回错误，要求删除其中一个。如果只有一个文件，则只加载该文件的数据，数据的格式是json,内容是这个样子</p><figure class="highlight json">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"topics"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"channels"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"ch1"</span>,</span><br><span class="line">                    <span class="attr">"paused"</span>: <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"tp1"</span>,</span><br><span class="line">            <span class="attr">"paused"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.1-alpha"</span></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="保存数据回本地文件">  <a href="#保存数据回本地文件" class="headerlink" title="保存数据回本地文件"></a>保存数据回本地文件</h4><p>topics在每次创建/删除是都会同步到文件，添加或删除channels也会同步到文件，使用的的方法就是  <code>PersistMetadata</code>,以后这详细介绍如何触发保存到文件动作，这里只是简单介绍一下保存过程中主要做了哪些事</p><p>主要分为两个部分</p><ul>  <li>嵌套循环topic 和 topic内的channel，写入文件</li>  <li>通过创建tmp文件，在rename方式写入数据，然后再创建一个软连接</li></ul><h5 id="第一个部分是获取元数据">  <a href="#第一个部分是获取元数据" class="headerlink" title="第一个部分是获取元数据"></a>第一个部分是获取元数据</h5><p>遍历nsq.topicMap, topicMap是目前我认为最重要的结构，主要的数据都保存在这个结构中。遍历topicMap中的每一个topic，只取出topic的name和paused两个属性值保存下来，然后便利topic.channelMap同样只取出name和paused连个属性，在这两层循环中都判断了是否是临时的，ephemeral这个以后还会见到很多次，topic或是channel的name中带有  <code>#ephemeral</code>都被认为是临时的，不会读取，也不会保存。取出所有topic和channel后序列化成json保存入临时文件。</p><h5 id="临时文件和软连接">  <a href="#临时文件和软连接" class="headerlink" title="临时文件和软连接"></a>临时文件和软连接</h5><p>写临时文件然后在rename到真正要保存的文件名，这个属于标准流程，肯定不能直接写目标文件，万一出错或发生意外避免影响到源文件/目标文件，写入成功后在rename安全多了。</p><p>为什么创建软连接，其实上面加载过程中加载的两个文件就来源于这里，如果是软连接，读出来的内容自然一样，看来还是为了兼容以前的版本。</p><p>做完上面的事，就要进入真正的启动和监听部分  <code>nsq.Main</code></p>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> Nsq </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>奇怪的问题记录</title>
      <link href="/2018/06/08/%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/06/08/%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>一些在工作中遇到的奇怪问题的记录，方便回忆查找  <br>  <a id="more"></a></p><h3 id="Mac-OS-X-下目录名大小写不敏感问题">  <a href="#Mac-OS-X-下目录名大小写不敏感问题" class="headerlink" title="Mac OS X 下目录名大小写不敏感问题"></a>Mac OS X 下目录名大小写不敏感问题</h3><p>在Terminal里，  <code>cd</code> 命令可以进入一个忽略大小写的目录，比如我有一个目录，  <code>~/Go</code>,我可以  <code>cd ~/Go</code>,也可以  <code>cd ~/go</code>，实际上这两个命令进入的是同一个目录。进而发现Mac默认文件和目录是不区分大小写的（这个有点反*inux），但是多数程序是关系区分大小写的。所以就出现问题了。</p><p>在一个Nsq的项目里使用的vendor作依赖管理，用dep也已经下载好了，但是test通不过，build也不行，说找不到package，而且从错误信息上看，只搜索了GOPATH和GOROOT，检查vendor目录，依赖包都在，怎么也找不到原因，最后猜测可能和目录大小写有关，因为之前是  <code>cd go</code>而目录名是Go，这次  <code>cd Go</code>然后逐层进入，再次test，果然好了</p><blockquote>  <p>总结：OS X 默认不区分大小写，在Terminal使用的时候要注意目录名称，或者统一使用小写避免问题，另外可以新建一个大小写敏感的分区</p></blockquote><p>  <a href="http://blog.bihe0832.com/mac-disk-utility.html" target="_blank" rel="noopener">OS X 中设置大小写敏感的分区并切换</a></p>]]></content>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac下使用dokcer搭建开发环境记录</title>
      <link href="/2018/06/01/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8dokcer%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/06/01/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8dokcer%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<pre><code>搭建环境中一些知识点的记录，帮助自己回忆一些遇到的问题</code></pre><a id="more"></a><h2 id="背景">  <a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>工作内容包含多个项目，对应语言为php，不同项目独立维护，通过不同的域名接入，系统之间通过http交换信息。目标是实现一个一键式脚本，搭建一个开发环境可以同时支持多个项目运行，其实就是Nginx+php-fpm的docker+git  checkout代码，然后  <code>docker-compose</code>一起管理。  <br>有两个注意点</p><ul>  <li>多个项目同时存在，需要通过域名区分每个项目的入口地址</li>  <li>多个项目在不同的git项目上，最好能一次性准备好</li></ul><h3 id="阿里云的docker源">  <a href="#阿里云的docker源" class="headerlink" title="阿里云的docker源"></a>阿里云的docker源</h3><p>为了解决docker pull 的问题优先使用的是  <a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">阿里云</a>的仓库，在上面找的nginx和php-fpm，需要注意的是上面的发布的image不一定都是好用的，pull之后检查一下是否符合需求。</p><h3 id="build自己的image">  <a href="#build自己的image" class="headerlink" title="build自己的image"></a>build自己的image</h3><p>制作这个一键式脚本最花费时间的地方是，想要重新build一个image，默认包含nginx的配置。不同域名对应不同的项目，一个docker通过nginx配置同时支持多个项目。当然配置域名后要在本地修改hosts文件才能正常访问。制作image就需要写一个Dockerfile，目的就是copy一些  <code>nginx_xxx.conf</code>的配置文件进去，其他的信息不用修改。在这里学到了两个知识点：</p><ul>  <li>使用    <code>doker inspect [image_id]</code>可以查看某个镜像的当前设置，包含    <code>CMD</code>    <code>Volumes</code>    <code>EXPOSE</code>等，如下图</li>  <li>在基于原来的image制作新的时，只需要设置需要修改的部分即可，不需要每个Dokcerfile都填写完全的信息，比如我这个需求就是添加一些配置文件，那么Dockerfile就可以只有    <code>FROM</code>和    <code>COPY</code>  </li></ul><p>  <img src="/img/docker-inspect.png" alt=""></p><h3 id="docker-compose关联多个docker">  <a href="#docker-compose关联多个docker" class="headerlink" title="docker-compose关联多个docker"></a>docker-compose关联多个docker</h3><p>制作工程中还有一个点学习到的就是docker-compose.yml中可以通过links方便的的吧两个docker连通，这个词可能不准确，我的理解是可能互相认识，可以通过名字访问到对方</p><h3 id="mysql密码问题">  <a href="#mysql密码问题" class="headerlink" title="mysql密码问题"></a>mysql密码问题</h3><p>运行mysql的docker时，需要指定一个重要的环境变量  <code>MYSQL_ROOT_PASSWORD</code>，最好加上  <code>MYSQL_ROOT_HOST=%</code>，但是好多地方都没有说明挂载data的问题，自己就遇到了设置了  <code>MYSQL_ROOT_PASSWORD</code>但是连接失败的问题，原因就在挂载  <code>/var/lib/msyql</code>这个目录的时候里面有上次运行的文件，导致没能将新的密码设置进去。简单的方法就是第一次启动前确认挂载的目录是空的，保证这次启动时完全初始化的。</p><h3 id="sudo-和重定向问题">  <a href="#sudo-和重定向问题" class="headerlink" title="sudo 和重定向问题"></a>sudo 和重定向问题</h3><p>在制作一键式脚本时，因为要更新hosts文件，需要执行类似  <br>  <code>sudo echo &quot;$hosts_conf&quot; &gt;&gt;/etc/hosts</code>  <br>一直提示  <code>Permission denied</code>，感觉sudo没起作用，实际上是sudo只授权给了  <code>echo</code>而重定向  <code>&gt;&gt;</code>也需要sudo权限，搜索结果y  <br>  <code>sudo sh -c &quot;echo \&quot;$host_config\&quot; &gt;&gt; /etc/hostscd &quot;</code>  <br>感觉上有点像eval的样子，将所有动作都包含在一起了</p><h3 id="sed替换路径问题">  <a href="#sed替换路径问题" class="headerlink" title="sed替换路径问题"></a>sed替换路径问题</h3><p>sed替换字符串中的某些特定字符很简单</p><p>  <code>sed &quot;s/abc/ABC/g&quot; filename.txt</code></p><p>使用变量的话</p><p>  <code>sed &quot;s/$src/$dst/g&quot; filename.txt</code></p><p>但是如果变量中带有  <code>/</code>就又问题，一个方法是保证变量内的  <code>/</code>被替换为  <code>\/</code>转义后在传进来，不过还有一个更好的办法</p><p>  <code>sed &quot;s#$src#$dst#g&quot;</code></p><p>这样  <code>/</code>就不需要转义了</p><h3 id="host问题">  <a href="#host问题" class="headerlink" title="host问题"></a>host问题</h3><p>由于多个php项目都在同一个挂载目录，同时不同项目使用了不同的域名，且不同项目见接口调用使用了域名进行访问。一开始只有本机配置了hosts文件，保证本地访问时可以通过127.0.0.1  访问正常，但是遇到项目间接口调用的时候出现了Connection Refuse。原因是php-fpm docker内查找域名的时候没有找到，所以通过本机得到了域名指向的是127.0.0.1，于是访问本地，然后出错了，因为对于本机来说127.0.0.1已经和docker做了端口映射，但是php-fpm内部访问的自己内部的端口，需要让php-fpm访问nginx的端口就对了。最近解决方法是给每个容器指定ip，且给php-fpm增加host配置</p><figure class="highlight yml">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">      finance-network:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">172.28</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line"><span class="attr">   extra_hosts:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"dev.xxx.xxx.com:172.28.0.11"</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  finance-network:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">bridge</span></span><br><span class="line"><span class="attr">    ipam:</span></span><br><span class="line"><span class="attr">      driver:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">      config:</span></span><br><span class="line"><span class="attr">        - subnet:</span> <span class="number">172.28</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br></pre>      </td>    </tr>  </table></figure>]]></content>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>笔记博客开坑</title>
      <link href="/2018/05/30/%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%9D%91/"/>
      <url>/2018/05/30/%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>列举一下接下来要开坑的分类  <br>  <a id="more"></a></p><h2 id="开坑分类">  <a href="#开坑分类" class="headerlink" title="开坑分类"></a>开坑分类</h2><ul>  <li>日常吐槽</li>  <li>经验总结</li>  <li>算法学习</li>  <li>go 源码和源码包学习</li>  <li>开源项目和源码学习</li>  <li>自己的项目</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
