<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Nsq源码学习笔记（一）----nsqd启动</title>
      <link href="/2018/06/08/Nsq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89----nsqd%E5%90%AF%E5%8A%A8/"/>
      <url>/2018/06/08/Nsq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89----nsqd%E5%90%AF%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>nsqd启动代码学习<br><a id="more"></a></p><h4 id="版本：1-0-1-alpha"><a href="#版本：1-0-1-alpha" class="headerlink" title="版本：1.0.1-alpha"></a>版本：1.0.1-alpha</h4><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>nsqd的入口代码位于：<code>$GOPATH//github.com/nsqio/nsq/apps/nsqd/nsqd.go</code></p><p>nsqd代码在<code>$GOPATH//github.com/nsqio/nsq/nsqd</code></p><h3 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>入口函数就是<code>main</code></p><p><code>main</code> 一共4行，run一个<code>program.Start</code>直到收到结束信息（Control+C或是kill）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prg := &amp;program&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := svc.Run(prg, syscall.SIGINT, syscall.SIGTERM); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p><code>program.Start</code> 就是启动的主要内容分别如下：</p><ul><li>(解析参数，存入opts)[<a href="http://aaaaa#参数解析]" target="_blank" rel="noopener">http://aaaaa#参数解析]</a></li><li>通过opts new一个nsqd</li><li>加载数据，指的是从本地文件加载topic和topic的channel</li><li>保存数据回本地文件</li><li>进入nsqd.Main</li></ul><h4 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>参数解析使用的是go自带的<code>flag</code>包，解析<code>nsqd --help</code>中参数，其中<code>options.Resolve(opts, flagSet, cfg)</code>作用还不能确定，稍后补上</p><h4 id="通过opts-new一个nsqd"><a href="#通过opts-new一个nsqd" class="headerlink" title="通过opts new一个nsqd"></a>通过opts new一个nsqd</h4><p>如果通过options创建一个nsqd，首先看一下nsqd结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NSQD <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 64bit atomic vars need to be first for proper alignment on 32bit platforms</span></span><br><span class="line">clientIDSequence <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">sync.RWMutex</span><br><span class="line"></span><br><span class="line">opts atomic.Value</span><br><span class="line"></span><br><span class="line">dl        *dirlock.DirLock <span class="comment">// 本地数据文件目录的锁</span></span><br><span class="line">isLoading <span class="keyword">int32</span> <span class="comment">// 是否处于加载本地数据过程中</span></span><br><span class="line">errValue  atomic.Value</span><br><span class="line">startTime time.Time <span class="comment">// 启动时间</span></span><br><span class="line"></span><br><span class="line">topicMap <span class="keyword">map</span>[<span class="keyword">string</span>]*Topic <span class="comment">// 所有topic存储在这里</span></span><br><span class="line"></span><br><span class="line">lookupPeers atomic.Value</span><br><span class="line"></span><br><span class="line">tcpListener   net.Listener</span><br><span class="line">httpListener  net.Listener</span><br><span class="line">httpsListener net.Listener</span><br><span class="line">tlsConfig     *tls.Config <span class="comment">// tls配置信息</span></span><br><span class="line"></span><br><span class="line">poolSize <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">notifyChan           <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">optsNotificationChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">exitChan             <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 退出信号</span></span><br><span class="line">waitGroup            util.WaitGroupWrapper</span><br><span class="line"></span><br><span class="line">ci *clusterinfo.ClusterInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构中每个属性的意义和作用，随着创建和启动逐步完善<br>创建nsqd实例前先做了两件事：</p><ul><li>首先检查了是否指定了<code>data-path</code>，如果没有使用当前目录，为什么创建实例前一定要确定目录，稍后提到</li><li>给options创建了一个Logger，为什么不是给nsqd增加Logger而是给了options，还有怎么使用，稍后需要注意一下。(填坑：nsqd专门创建logger函数，内部使用的就是options.Logger，对外的实现是n.logf)</li></ul><p>创建实例，nsqd没有一次创建所有属性</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">n := &amp;NSQD&#123;</span><br><span class="line">startTime:            time.Now(), <span class="comment">// 当前时间，也就是启动时间</span></span><br><span class="line">topicMap:             <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Topic), <span class="comment">// 这个很关键了，需要下次专门介绍，用于保存所有topic的结构</span></span><br><span class="line">exitChan:             <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="comment">// 退出信号</span></span><br><span class="line">notifyChan:           <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;), <span class="comment">// 还不知道，稍后填坑</span></span><br><span class="line">optsNotificationChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>), <span class="comment">// 不知道，稍后填坑</span></span><br><span class="line">dl:                   dirlock.New(dataPath), <span class="comment">// 上面提到的数据目录，为了防止多个进程使用同一个目录，需要对目录加锁，稍后详细提到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化http api client<code>n.ci = clusterinfo.New(n.logf, httpcli)</code>,同时日志输出保持一致</p><p>指定日志输出等级<code>opts.logLevel, err = lg.ParseLogLevel(opts.LogLevel, opts.Verbose)</code></p><p>给数据目录上锁，应该是独占锁，保证其他进程不能在上锁，Ulock动作在Exit才执行，也就是说整个进程执行期间，都是锁住的</p><p>接下来是一些参数检查，和tls配置检查<br>然后返回整个nsqd的实例</p><h4 id="加载本地数据"><a href="#加载本地数据" class="headerlink" title="加载本地数据"></a>加载本地数据</h4><p><code>nsqd.LoadMetadata()</code>从本地文件加载数据<br>文件加载过程专门使用atomic标示加载过程</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atomic.StoreInt32(&amp;n.isLoading, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> atomic.StoreInt32(&amp;n.isLoading, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>应该是为了兼容老的版本，加载的时候需要加载两个文件，其中一个包含ID信息是老版本的文件，读取两个文件后进行比对，如果不一致，返回错误，要求删除其中一个。如果只有一个文件，则只加载该文件的数据，数据的格式是json,内容是这个样子</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"topics"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"channels"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"ch1"</span>,</span><br><span class="line">                    <span class="attr">"paused"</span>: <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"tp1"</span>,</span><br><span class="line">            <span class="attr">"paused"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.1-alpha"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="保存数据回本地文件"><a href="#保存数据回本地文件" class="headerlink" title="保存数据回本地文件"></a>保存数据回本地文件</h4><p>topics在每次创建/删除是都会同步到文件，添加或删除channels也会同步到文件，使用的的方法就是<code>PersistMetadata</code>,以后这详细介绍如何触发保存到文件动作，这里只是简单介绍一下保存过程中主要做了哪些事</p><p>主要分为两个部分</p><ul><li>嵌套循环topic 和 topic内的channel，写入文件</li><li>通过创建tmp文件，在rename方式写入数据，然后再创建一个软连接</li></ul><h5 id="第一个部分是获取元数据"><a href="#第一个部分是获取元数据" class="headerlink" title="第一个部分是获取元数据"></a>第一个部分是获取元数据</h5><p>遍历nsq.topicMap,    topicMap是目前我认为最重要的结构，主要的数据都保存在这个结构中。遍历topicMap中的每一个topic，只取出topic的name和paused两个属性值保存下来，然后便利topic.channelMap同样只取出name和paused连个属性，在这两层循环中都判断了是否是临时的，ephemeral这个以后还会见到很多次，topic或是channel的name中带有<code>#ephemeral</code>都被认为是临时的，不会读取，也不会保存。取出所有topic和channel后序列化成json保存入临时文件。</p><h5 id="临时文件和软连接"><a href="#临时文件和软连接" class="headerlink" title="临时文件和软连接"></a>临时文件和软连接</h5><p>写临时文件然后在rename到真正要保存的文件名，这个属于标准流程，肯定不能直接写目标文件，万一出错或发生意外避免影响到源文件/目标文件，写入成功后在rename安全多了。</p><p>为什么创建软连接，其实上面加载过程中加载的两个文件就来源于这里，如果是软连接，读出来的内容自然一样，看来还是为了兼容以前的版本。</p><p>做完上面的事，就要进入真正的启动和监听部分<code>nsq.Main</code></p>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> Nsq </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>奇怪的问题记录</title>
      <link href="/2018/06/08/%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/06/08/%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>一些在工作中遇到的奇怪问题的记录，方便回忆查找<br><a id="more"></a></p><h3 id="Mac-OS-X-下目录名大小写不敏感问题"><a href="#Mac-OS-X-下目录名大小写不敏感问题" class="headerlink" title="Mac OS X 下目录名大小写不敏感问题"></a>Mac OS X 下目录名大小写不敏感问题</h3><p>在Terminal里，<code>cd</code> 命令可以进入一个忽略大小写的目录，比如我有一个目录，<code>~/Go</code>,我可以<code>cd ~/Go</code>,也可以<code>cd ~/go</code>，实际上这两个命令进入的是同一个目录。进而发现Mac默认文件和目录是不区分大小写的（这个有点反*inux），但是多数程序是关系区分大小写的。所以就出现问题了。</p><p>在一个Nsq的项目里使用的vendor作依赖管理，用dep也已经下载好了，但是test通不过，build也不行，说找不到package，而且从错误信息上看，只搜索了GOPATH和GOROOT，检查vendor目录，依赖包都在，怎么也找不到原因，最后猜测可能和目录大小写有关，因为之前是<code>cd go</code>而目录名是Go，这次<code>cd Go</code>然后逐层进入，再次test，果然好了</p><blockquote><p>总结：OS X 默认不区分大小写，在Terminal使用的时候要注意目录名称，或者统一使用小写避免问题，另外可以新建一个大小写敏感的分区</p></blockquote><p><a href="http://blog.bihe0832.com/mac-disk-utility.html" target="_blank" rel="noopener">OS X 中设置大小写敏感的分区并切换</a></p>]]></content>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac下使用dokcer搭建开发环境记录</title>
      <link href="/2018/06/01/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8dokcer%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/06/01/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8dokcer%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<pre><code>搭建环境中一些知识点的记录，帮助自己回忆一些遇到的问题</code></pre><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>工作内容包含多个项目，对应语言为php，不同项目独立维护，通过不同的域名接入，系统之间通过http交换信息。目标是实现一个一键式脚本，搭建一个开发环境可以同时支持多个项目运行，其实就是Nginx+php-fpm的docker+git checkout代码，然后<code>docker-compose</code>一起管理。<br>有两个注意点</p><ul><li>多个项目同时存在，需要通过域名区分每个项目的入口地址</li><li>多个项目在不同的git项目上，最好能一次性准备好</li></ul><h3 id="阿里云的docker源"><a href="#阿里云的docker源" class="headerlink" title="阿里云的docker源"></a>阿里云的docker源</h3><p>为了解决docker pull 的问题优先使用的是<a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">阿里云</a>的仓库，在上面找的nginx和php-fpm，需要注意的是上面的发布的image不一定都是好用的，pull之后检查一下是否符合需求。</p><h3 id="build自己的image"><a href="#build自己的image" class="headerlink" title="build自己的image"></a>build自己的image</h3><p>制作这个一键式脚本最花费时间的地方是，想要重新build一个image，默认包含nginx的配置。不同域名对应不同的项目，一个docker通过nginx配置同时支持多个项目。当然配置域名后要在本地修改hosts文件才能正常访问。制作image就需要写一个Dockerfile，目的就是copy一些<code>nginx_xxx.conf</code>的配置文件进去，其他的信息不用修改。在这里学到了两个知识点：</p><ul><li>使用<code>doker inspect [image_id]</code>可以查看某个镜像的当前设置，包含<code>CMD</code> <code>Volumes</code> <code>EXPOSE</code>等，如下图</li><li>在基于原来的image制作新的时，只需要设置需要修改的部分即可，不需要每个Dokcerfile都填写完全的信息，比如我这个需求就是添加一些配置文件，那么Dockerfile就可以只有<code>FROM</code>和<code>COPY</code></li></ul><p><img src="/img/docker-inspect.png" alt=""></p><h3 id="docker-compose关联多个docker"><a href="#docker-compose关联多个docker" class="headerlink" title="docker-compose关联多个docker"></a>docker-compose关联多个docker</h3><p>制作工程中还有一个点学习到的就是docker-compose.yml中可以通过links方便的的吧两个docker连通，这个词可能不准确，我的理解是可能互相认识，可以通过名字访问到对方</p><h3 id="mysql密码问题"><a href="#mysql密码问题" class="headerlink" title="mysql密码问题"></a>mysql密码问题</h3><p>运行mysql的docker时，需要指定一个重要的环境变量<code>MYSQL_ROOT_PASSWORD</code>，最好加上<code>MYSQL_ROOT_HOST=%</code>，但是好多地方都没有说明挂载data的问题，自己就遇到了设置了<code>MYSQL_ROOT_PASSWORD</code>但是连接失败的问题，原因就在挂载<code>/var/lib/msyql</code>这个目录的时候里面有上次运行的文件，导致没能将新的密码设置进去。简单的方法就是第一次启动前确认挂载的目录是空的，保证这次启动时完全初始化的。</p><h3 id="sudo-和重定向问题"><a href="#sudo-和重定向问题" class="headerlink" title="sudo 和重定向问题"></a>sudo 和重定向问题</h3><p>在制作一键式脚本时，因为要更新hosts文件，需要执行类似<br><code>sudo echo &quot;$hosts_conf&quot; &gt;&gt;/etc/hosts</code><br>一直提示<code>Permission denied</code>，感觉sudo没起作用，实际上是sudo只授权给了<code>echo</code>而重定向<code>&gt;&gt;</code>也需要sudo权限，搜索结果y<br><code>sudo sh -c &quot;echo \&quot;$host_config\&quot; &gt;&gt; /etc/hostscd &quot;</code><br>感觉上有点像eval的样子，将所有动作都包含在一起了</p><h3 id="sed替换路径问题"><a href="#sed替换路径问题" class="headerlink" title="sed替换路径问题"></a>sed替换路径问题</h3><p>sed替换字符串中的某些特定字符很简单</p><p><code>sed &quot;s/abc/ABC/g&quot; filename.txt</code> </p><p>使用变量的话</p><p><code>sed &quot;s/$src/$dst/g&quot; filename.txt</code></p><p>但是如果变量中带有<code>/</code>就又问题，一个方法是保证变量内的<code>/</code>被替换为<code>\/</code>转义后在传进来，不过还有一个更好的办法</p><p><code>sed &quot;s#$src#$dst#g&quot;</code></p><p>这样<code>/</code>就不需要转义了</p><h3 id="host问题"><a href="#host问题" class="headerlink" title="host问题"></a>host问题</h3><p>由于多个php项目都在同一个挂载目录，同时不同项目使用了不同的域名，且不同项目见接口调用使用了域名进行访问。一开始只有本机配置了hosts文件，保证本地访问时可以通过127.0.0.1 访问正常，但是遇到项目间接口调用的时候出现了Connection Refuse。原因是php-fpm docker内查找域名的时候没有找到，所以通过本机得到了域名指向的是127.0.0.1，于是访问本地，然后出错了，因为对于本机来说127.0.0.1已经和docker做了端口映射，但是php-fpm内部访问的自己内部的端口，需要让php-fpm访问nginx的端口就对了。最近解决方法是给每个容器指定ip，且给php-fpm增加host配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">      finance-network:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">172.28</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line"><span class="attr">   extra_hosts:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"dev.xxx.xxx.com:172.28.0.11"</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  finance-network:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">bridge</span></span><br><span class="line"><span class="attr">    ipam:</span></span><br><span class="line"><span class="attr">      driver:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">      config:</span></span><br><span class="line"><span class="attr">        - subnet:</span> <span class="number">172.28</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>笔记博客开坑</title>
      <link href="/2018/05/30/%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%9D%91/"/>
      <url>/2018/05/30/%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>列举一下接下来要开坑的分类<br><a id="more"></a></p><h2 id="开坑分类"><a href="#开坑分类" class="headerlink" title="开坑分类"></a>开坑分类</h2><ul><li>日常吐槽</li><li>经验总结</li><li>算法学习</li><li>go 源码和源码包学习</li><li>开源项目和源码学习</li><li>自己的项目</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
