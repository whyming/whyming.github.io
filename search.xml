<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>ARTS-第二周</title>
      <link href="/2019/04/14/ARTS-2/"/>
      <url>/2019/04/14/ARTS-2/</url>
      <content type="html"><![CDATA[<p>ARTS打卡第二周</p><p>A: leetcode 3Sum， Midum</p><p>R：http断点续传协议TUS</p><p>T: 利用git commit 回滚代码，阅读庞大项目</p><p>S：go-nats代码阅读</p><a id="more"></a><p>[TOC]</p><h3 id="A-leetcode-3Sum，-Midum">  <a href="#A-leetcode-3Sum，-Midum" class="headerlink" title="A: leetcode 3Sum， Midum"></a>A: leetcode 3Sum， Midum</h3><p>实际做了3道题，不过  <code>intToRoman</code>和  <code>romanToInt</code>这两题难度较低，意义不大，于是尝试这道  <code>3sum</code></p><p>自己的实现：</p><details>  <br>  <summary>自己的实现</summary>  <br>  <br>  <figure class="highlight go">    <table>      <tr>        <td class="gutter">          <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre>        </td>        <td class="code">          <pre><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[j] &gt; nums[i]</span><br><span class="line">&#125;)</span><br><span class="line">positiveMap := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> index, i := <span class="keyword">range</span> nums &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">positiveMap[i] = index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">currA := nums[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> nums[i] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> currA == nums[i] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">currA = nums[i]</span><br><span class="line">currB := nums[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line"><span class="keyword">if</span> currB == nums[j] &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">currB = nums[j]</span><br><span class="line">target := <span class="number">0</span> - (nums[i] + nums[j])</span><br><span class="line"><span class="keyword">if</span> c, ok := positiveMap[target]; ok &#123;</span><br><span class="line"><span class="keyword">if</span> c &gt; j &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;</span><br><span class="line">nums[i], nums[j], target,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre>        </td>      </tr>    </table>  </figure>  <br>  <br></details><p> 运行结果：</p><blockquote>  <p>Runtime: 936 ms, faster than 48.61% of Go online submissions for 3Sum.</p>  <p>Memory Usage: 340.6 MB, less than 30.93% of Go online submissions for 3Sum.</p></blockquote><p>参考大神代码后的结果：</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">threeSum</span><span class="params">(nums []<span class="keyword">int</span>)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">result := [][]<span class="keyword">int</span>&#123;&#125;</span><br><span class="line">sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> nums[i] &lt; nums[j]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-2</span> &amp;&amp; nums[i] &lt;= <span class="number">0</span>; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &#123; <span class="comment">// 重复的跳过</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// s指向数组开头即最小值，e指向最后，即最大值</span></span><br><span class="line">s, e, target := i+<span class="number">1</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>, <span class="number">0</span>-nums[i]</span><br><span class="line"><span class="keyword">for</span> s &lt; e &#123;</span><br><span class="line"><span class="comment">// fmt.Printf("nums %+v\n s: %d, e:%d\n", nums, s, e)</span></span><br><span class="line"><span class="keyword">if</span> nums[s]+nums[e] == target &#123;</span><br><span class="line">result = <span class="built_in">append</span>(result, []<span class="keyword">int</span>&#123;</span><br><span class="line">nums[i], nums[s], nums[e],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">for</span> s &lt; e &amp;&amp; nums[s] == nums[s+<span class="number">1</span>] &#123;</span><br><span class="line">s++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> s &lt; e &amp;&amp; nums[e] == nums[e<span class="number">-1</span>] &#123;</span><br><span class="line">e--</span><br><span class="line">&#125;</span><br><span class="line">s++</span><br><span class="line">e--</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[s]+nums[e] &gt; target &#123; <span class="comment">// 结果大于逾期，需要最大值减小</span></span><br><span class="line">e--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">s++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>运行结果：</p><blockquote>  <p>Runtime: 868 ms, faster than 91.25% of Go online submissions for 3Sum.</p>  <p>Memory Usage: 205.1 MB, less than 98.97% of Go online submissions for 3Sum.</p></blockquote><h3 id="R：http断点续传协议TUS">  <a href="#R：http断点续传协议TUS" class="headerlink" title="R：http断点续传协议TUS"></a>R：http断点续传协议TUS</h3><p>  <a href="https://golangbot.com/understanding-tus/" target="_blank" rel="noopener">Resumable file uploader: Understanding tus protocol</a></p><p>通过http方式解决大文件断点续传问题，主要通过三个步骤实现：</p><ul>  <li>http    <code>POST</code>方法,创建文件，返回rest格式的文件地址</li>  <li>http    <code>PATCH</code>方案更新文件，每次传入更新的    <code>Upload-Offset</code>和    <code>Content-Length</code>,</li>  <li>http    <code>HEAD</code>返回文件更新位置，即最后一次    <code>PATCH</code>的位置</li></ul><h3 id="T-利用git-commit-回滚代码，阅读庞大项目">  <a href="#T-利用git-commit-回滚代码，阅读庞大项目" class="headerlink" title="T: 利用git commit 回滚代码，阅读庞大项目"></a>T: 利用git commit 回滚代码，阅读庞大项目</h3><p>这个技巧来自于公众号一个大神的推荐，  <a href="https://mp.weixin.qq.com/s/LsGEr_RJYfAbGBBlRxJH-Q" target="_blank" rel="noopener">开源代码学习技巧</a></p><p>内容主要就是clone整个项目后，可以通过提交历史找到一个较早的可用提交，个人经验可以看tag名称，比如v0.01，v0.24,这种，或是看具体的commit message，这样可以看到最小功能的项目代码，理解最初意图，主要是降低阅读代价，然后不断向后移动提交位置，不仅可以逐步阅读完代码，还可以看到作者在每次更新的主要内容。</p><h3 id="S：go-nats代码阅读">  <a href="#S：go-nats代码阅读" class="headerlink" title="S：go-nats代码阅读"></a>S：go-nats代码阅读</h3><p>用上面提到的技巧，自己整理了一下第一版go-nats代码，很快就看懂了，接下来会阅读  <code>v0.6</code>，这样逐步完成整个项目阅读</p><p>  <img src="image-20190414102359041.png" alt="image-20190414102359041"></p>]]></content>
      
      
        <tags>
            
            <tag> ARTS </tag>
            
            <tag> golang </tag>
            
            <tag> 打卡 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ARTS 第一周</title>
      <link href="/2019/04/01/ARTS-%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
      <url>/2019/04/01/ARTS-%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
      <content type="html"><![CDATA[<p>  <a href="https://www.zhihu.com/question/301150832" target="_blank" rel="noopener">《左耳听风》发起的ARTS挑战</a></p><blockquote>  <p>    <strong>Algorithm</strong>。    <strong>主要是为了编程训练和学习。</strong>每周至少做一个 leetcode 的算法题（先从Easy开始，然后再Medium，最后才Hard）。进行编程训练，如果不训练你看再多的算法书，你依然不会做算法题，看完书后，你需要训练。关于做Leetcode的的优势，你可以看一下我在coolshell上的文章    <a href="https://link.zhihu.com/?target=https%3A//coolshell.cn/articles/12052.html" target="_blank" rel="noopener">Leetcode 编程训练 - 酷 壳 - CoolShell</a>。</p>  <p>    <strong>Review：主要是为了学习英文，如果你的英文不行，你基本上无缘技术高手。</strong>所以，需要你阅读并点评至少一篇英文技术文章，我个人最喜欢去的地方是    <a href="https://link.zhihu.com/?target=http%3A//Medium.com" target="_blank" rel="noopener">http://Medium.com</a>（需要梯子）以及各个公司的技术blog，如Netflix的。</p>  <p>    <strong>Tip：主要是为了总结和归纳你在是常工作中所遇到的知识点</strong>。学习至少一个技术技巧。你在工作中遇到的问题，踩过的坑，学习的点滴知识。</p>  <p>    <strong>Share：主要是为了建立你的影响力，能够输出价值观。</strong>分享一篇有观点和思考的技术文章。</p>  <p>作者：陈皓</p></blockquote><a id="more"></a><h3 id="Algorithm">  <a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>上次写了几个题，这次接着继续主要是easy和medium</p><p>这次是medium：  <a href="https://leetcode.com/problems/string-to-integer-atoi" target="_blank" rel="noopener">字符串转数值</a></p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAtoi</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">isNegative = <span class="number">0</span></span><br><span class="line">validLen   <span class="keyword">int32</span></span><br><span class="line">startNum   <span class="keyword">bool</span></span><br><span class="line">Max        = <span class="number">2</span> &lt;&lt; <span class="number">30</span></span><br><span class="line">MaxPre     = <span class="number">2</span> &lt;&lt; <span class="number">30</span> / <span class="number">10</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">l := <span class="built_in">len</span>(str)</span><br><span class="line"><span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">LOOP:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; l; i++ &#123;</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> !startNum &amp;&amp; isNegative == <span class="number">0</span> &amp;&amp; str[i] == <span class="string">' '</span>:</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> !startNum &amp;&amp; isNegative == <span class="number">0</span> &amp;&amp; str[i] == <span class="string">'-'</span>:</span><br><span class="line">isNegative = <span class="number">-1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> !startNum &amp;&amp; isNegative == <span class="number">0</span> &amp;&amp; str[i] == <span class="string">'+'</span>:</span><br><span class="line">isNegative = <span class="number">1</span></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"><span class="keyword">case</span> str[i] &lt; <span class="string">'0'</span> || str[i] &gt; <span class="string">'9'</span>:</span><br><span class="line"><span class="keyword">break</span> LOOP</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> isNegative == <span class="number">0</span> &#123;</span><br><span class="line">isNegative = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> str[i] == <span class="string">'0'</span> &amp;&amp; result == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">startNum = <span class="literal">true</span></span><br><span class="line">validLen++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> validLen &gt; <span class="number">10</span> || result &gt; MaxPre ||</span><br><span class="line">(result == MaxPre &amp;&amp; (isNegative == <span class="number">1</span> &amp;&amp; str[i] &gt; <span class="string">'7'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span> || isNegative == <span class="number">-1</span> &amp;&amp; str[i] == <span class="string">'9'</span>)) &#123;</span><br><span class="line"><span class="keyword">if</span> isNegative == <span class="number">1</span> &#123;</span><br><span class="line">result = Max - <span class="number">1</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">result = Max</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = result*<span class="number">10</span> + (<span class="keyword">int</span>(str[i]) - <span class="string">'0'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> isNegative != <span class="number">0</span> &#123;</span><br><span class="line">result = result * isNegative</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="Review">  <a href="#Review" class="headerlink" title="Review"></a>Review</h3><p>英文阅读确实是短板，从简单的入手吧，顺便当作收藏资源</p><p>  <a href="https://blog.usejournal.com/staying-in-the-know-with-go-9bf719ccc3d1" target="_blank" rel="noopener">关于go应该知道的一些知识</a></p><ul>  <li>    <a href="https://golangweekly.com/" target="_blank" rel="noopener">go周报</a>，大家都可以订阅一下，关于go的一些最新消息还有更新、文章、新闻等</li>  <li>    <a href="https://groups.google.com/forum/#!forum/golang-nuts" target="_blank" rel="noopener">go邮件列表1</a>，    <a href="https://groups.google.com/d/forum/golang-dev" target="_blank" rel="noopener">go开发者论坛</a>, 都是google自己家的，需要梯子，但是可以看到关于go的最新的讨论和发展</li>  <li>第三方论坛：    <a href="https://old.reddit.com/r/golang/" target="_blank" rel="noopener">reddit论坛</a>，</li>  <li>博客：    <a href="https://blog.feedspot.com/golang_blogs/" target="_blank" rel="noopener">号称top 20的golang博客的聚合</a>，看上去还不错</li>  <li>github 项目：    <a href="https://github.com/search?q=stars%3A%3E1000+language%3AGo+cache&amp;type=Repositories" target="_blank" rel="noopener">千星项目搜索</a>，千应该是受大家认可的项目了</li>  <li>GopherCon 开发者大会，这个看情况吧…</li></ul><h3 id="Tip">  <a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><p>刚好在写上面leetcode题的时候发现，go的字符型还是挺有意思的，当我按照下标去访问字符串元素的时候，得到的竟然是  <code>uint8</code>，同理，当定义一个字符的时候，其实也是使用了  <code>uint8</code>,其值就是对应的ascii码值，这样可以直接进行  <code>+-</code>操作，同时比较也很方便。</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">"abcd"</span></span><br><span class="line">tt := reflect.TypeOf(s[<span class="number">0</span>])</span><br><span class="line">vv := reflect.ValueOf(s[<span class="number">0</span>])</span><br><span class="line">fmt.Printf(<span class="string">"type is: %v\n"</span>, tt)</span><br><span class="line">fmt.Printf(<span class="string">"value is: %v\n"</span>, vv)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// type is: uint8</span></span><br><span class="line"><span class="comment">// value is: 97</span></span><br></pre>      </td>    </tr>  </table></figure><h3 id="Share">  <a href="#Share" class="headerlink" title="Share"></a>Share</h3><p>先分享一篇别人现成的吧</p><p>  <a href="https://mp.weixin.qq.com/s/H6r3EozpiRt5eY-3N_LUjw" target="_blank" rel="noopener">Go高级实践：反射3定律</a></p>]]></content>
      
      
        <tags>
            
            <tag> ARTS </tag>
            
            <tag> golang </tag>
            
            <tag> 打卡 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nsq源码学习笔记(二) --- nsqd消息订阅</title>
      <link href="/2019/03/18/Nsq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-nsqd%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85/"/>
      <url>/2019/03/18/Nsq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-nsqd%E6%B6%88%E6%81%AF%E8%AE%A2%E9%98%85/</url>
      <content type="html"><![CDATA[<p>nsqd.Main内部逻辑很少，启动了6个goroutine，下面简单说一下goroutine的作用</p><ul>  <li>tcpserver，监听客户端连接，很重要，下面消息订阅就是在这里面发生的</li>  <li>httpserver，监听http请求，提供rest api 服务</li>  <li>httpsserver，监听https请求，其实和http的一样</li>  <li>queueScanLoop，应该是监听消息队列的，稍后回来填坑</li>  <li>lookupLoop ，和nsqlookupd通信的</li>  <li>statsdLoop， 状态同步</li></ul><h4 id="tcpserver-获取订阅消息">  <a href="#tcpserver-获取订阅消息" class="headerlink" title="tcpserver 获取订阅消息"></a>tcpserver 获取订阅消息</h4><p>连接成功后，立刻读取前4个字节，  <code>[ ][ ][V][2]</code>,前两个空格应该是预留，这个是用来判断通信协议版本的，目前只有V2,</p><p>然后开始  <code>prot.IOLoop</code>, 这个是tcpserver最主要的事情了， 里面也主要包含两部分</p><ul>  <li>启动    <code>messagePump</code>,这是一个goroutine，处理消息转发等</li>  <li>循环读取client发来的消息，解析成命令并执行，同时还包含了维护心跳</li></ul><p>  <code>messagePump</code>通过循环读取多个chan来实现消息读取，事件触发，其中就包含对订阅消息的转发</p><p>当client发送一个  <code>SUB topicName Channel</code>给nsqd时， nsqd在检查topic和channel合法性后，会创建一个新的channel，放入  <code>subEventChan</code>，  <code>messagePump</code>监听并得到这个chan后，会继监听这个chan的消息，一旦这个channel有消息发来，则会将channel的消息转发给client，这样客户端就得到了订阅的消息推送。</p><p>channel的消息哪来的呢？原来在topic创建channel的时候，同时会把这channel加入topic的channel列表，当top接受到消息的时候，发送给列表中的每一个channel，这样可以实现一个topic，多个订阅channel都能得到消息。</p><p>另外因为topic在创建channel的时候使用的是  <code>getOrCreateChannel</code>从名字看就知道，如果已经存在这个名字的channel则直接返回已经存在的channel，如果不存在才创建。那么如果订阅了一个已经存在的channel，就是说别人也监听了的channel会怎么样呢，这个问题转换成了，如果一个go  channel多出代码读取，将随机的的一个读到消息，所以订阅同一个channel的客户端将随机收到消息。听说这样设计是为了实现客户端的均衡，可以让多个客户端随机消费同一个channel</p>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> Nsq </tag>
            
            <tag> 源码学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法200题训练02-平衡二叉树</title>
      <link href="/2018/07/23/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%8302-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2018/07/23/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%8302-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 算法 </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> 平衡二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go的反射库reflect学习</title>
      <link href="/2018/07/11/Go%E7%9A%84%E5%8F%8D%E5%B0%84%E5%BA%93reflect%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/07/11/Go%E7%9A%84%E5%8F%8D%E5%B0%84%E5%BA%93reflect%E5%AD%A6%E4%B9%A0/</url>
      <content type="html"><![CDATA[<p>鉴于官方手册并不是每个方法都给出了example，描述有很多也不是很清楚，所以光从doc是不能完全理解这个库，还是要动起手来</p><a id="more"></a><p>  <code>reflect</code>库提供了非常的多方法，但是这个库到底能做什么，不实际动手尝试一下还是没能理解。  <br>接下来从最基础两个类型开始：Type和Value</p><h4 id="Type-amp-TypeOf">  <a href="#Type-amp-TypeOf" class="headerlink" title="Type &amp; TypeOf"></a>Type &amp; TypeOf</h4><p>第一个重要的数据结构,先列一些稍后用的到的且好理解的</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// 调试常用，返回一个字符串表示的类型，比如[]map[string]int,表示一个map类型的切片</span></span><br><span class="line">String() <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// kind用到的也很多，返回的是类型，但是用int表示的，看代码理解吧</span></span><br><span class="line">Kind() Kind</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回元素的类型， 只有这些类型才有元素：Array、Chan、Map、Slice和Ptr，指针这个需要看代码理解</span></span><br><span class="line">Elem() Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回函数类型的参数个数，不是函数类型会panic，好理解</span></span><br><span class="line">NumIn() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回函数类型的第i个参数的类型，不是函数类型或是超过NumIn会panic</span></span><br><span class="line">In(i <span class="keyword">int</span>) Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和参数类型对应，这个是返回的个数</span></span><br><span class="line">NumOut() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和参数对应，返回参数的第i个是什么类型</span></span><br><span class="line">Out(i <span class="keyword">int</span>) Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回map的key类型，不是map类型就会panic，好理解,和Elem() 对应返回元素类型</span></span><br><span class="line">Key() Type</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回Array的length，如果不是Array类型就panic，好理解</span></span><br><span class="line">Len() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct 类型的field个数，如果不是struct类型panic，后面用的很多</span></span><br><span class="line">NumField() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>什么时候，以及怎么用Type呢，来看  <br>  <code>func TypeOf(i interface{}) Type</code></p><p>来两个简单的例子感受一下：</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">s = <span class="string">"abc"</span></span><br><span class="line">tp := reflect.TypeOf(s)</span><br><span class="line">tps := tp.String()</span><br><span class="line">fmt.Printf(<span class="string">"string s type is: #%s#"</span>,tps)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="keyword">string</span> s <span class="keyword">type</span> is: #<span class="keyword">string</span>#</span><br><span class="line"></span><br><span class="line">继续：</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> tp.Kind() == reflect.String &#123;</span><br><span class="line">fmt.Println(<span class="string">"s type is String"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"s type is NOT  String"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">s <span class="keyword">type</span> is String</span><br><span class="line"></span><br><span class="line">继续：</span><br><span class="line"></span><br><span class="line">sa := [<span class="number">3</span>]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;</span><br><span class="line">tp = reflect.TypeOf(sa)</span><br><span class="line">tps = tp.String()</span><br><span class="line"></span><br><span class="line">els := tp.Elem().String()</span><br><span class="line">fmt.Printf(<span class="string">"string array type is #%s# element type is #%s# length is %d\n"</span>, tps, els,tp.Len())</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="keyword">string</span> array <span class="keyword">type</span> is #[<span class="number">3</span>]<span class="keyword">string</span># element <span class="keyword">type</span> is #<span class="keyword">string</span># length is <span class="number">3</span></span><br><span class="line"></span><br><span class="line">继续：</span><br><span class="line"><span class="keyword">type</span> st <span class="keyword">struct</span> &#123;</span><br><span class="line">a <span class="keyword">int</span></span><br><span class="line">b <span class="keyword">string</span></span><br><span class="line">c <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">st1 := &amp;st&#123;</span><br><span class="line">a: <span class="number">1</span>,</span><br><span class="line">b: <span class="string">"abc"</span>,</span><br><span class="line">c: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>),</span><br><span class="line">&#125;</span><br><span class="line">tp = reflect.TypeOf(st1)</span><br><span class="line">tps = tp.String()</span><br><span class="line">fmt.Printf(<span class="string">"st1 type is #%s#\n"</span>, tps)</span><br><span class="line"><span class="keyword">if</span> tp.Kind() == reflect.Ptr &#123;</span><br><span class="line">fmt.Printf(<span class="string">"st1 type is a pointer\n"</span>)</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">st1 <span class="keyword">type</span> is #*testreflect.st#</span><br><span class="line">st1 <span class="keyword">type</span> is a pointer</span><br><span class="line">testreflect是我的<span class="keyword">package</span>名，另外注意这里有一个*</span><br><span class="line"></span><br><span class="line">继续：</span><br><span class="line">els = tp.Elem().String()</span><br><span class="line">fmt.Printf(<span class="string">"st1 element type is #%s#\n"</span>, els)</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">st1 element <span class="keyword">type</span> is #testreflect.st#</span><br><span class="line"></span><br><span class="line">这里没有*，因为Elem()在指针的时候得到的是原始类型，而不是指针</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tp.Elem().NumField(); i++ &#123;</span><br><span class="line">name := tp.Elem().Field(i).Name</span><br><span class="line">ktp := tp.Elem().Field(i).Type.String()</span><br><span class="line">fmt.Printf(<span class="string">"field name is %s, field type is %s\n"</span>, name, ktp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">field name is a, field <span class="keyword">type</span> is <span class="keyword">int</span></span><br><span class="line">field name is b, field <span class="keyword">type</span> is <span class="keyword">string</span></span><br><span class="line">field name is c, field <span class="keyword">type</span> is <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br></pre>      </td>    </tr>  </table></figure><p>小结：Type用来获取和判断 类型相关，甚至可以逐步剖析内部结构。TypeOf返回的是Type类型，Type里保存了这个变量的很多信息，具体需要使用对应的方法取得，如果用错方法会panic，比如不是Map类型，而调用Key(),本来这个方法是返回map的key类型，但是如果变量是string那么调用时就会panic，所以调用前一定要用Kind()判断好。感觉Kind()和switch可能是出现频率最高的。单一通过Type最多可以获得map的field  name或是map的key name，无法获得具体值，比如只能知道这个变量是int，具体是多少呢，不知道。接下来Value就是获取具体值的。</p><h4 id="Value-amp-VlaueOf">  <a href="#Value-amp-VlaueOf" class="headerlink" title="Value &amp; VlaueOf"></a>Value &amp; VlaueOf</h4><p>取得一个对象的值，并且还能生成一个同类型的新的对象。  <br>通过一个深度copy函数来理解value是最好的方式了，</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> testreflect</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line">a</span><br><span class="line"><span class="comment">// DeepCopy ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeepCopy</span><span class="params">(in <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(out <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">tp := reflect.TypeOf(in)</span><br><span class="line">val := reflect.ValueOf(in)</span><br><span class="line"><span class="keyword">switch</span> tp.Kind() &#123;</span><br><span class="line"><span class="keyword">case</span> reflect.Array:</span><br><span class="line"><span class="keyword">return</span> CloneArray(in)</span><br><span class="line"><span class="keyword">case</span> reflect.Map:</span><br><span class="line"><span class="keyword">return</span> CloneMap(in)</span><br><span class="line"><span class="keyword">case</span> reflect.Ptr:</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">case</span> reflect.Slice:</span><br><span class="line"><span class="keyword">return</span> CloneSlice(in)</span><br><span class="line"><span class="keyword">case</span> reflect.Struct:</span><br><span class="line"><span class="keyword">return</span> CloneStruct(in)</span><br><span class="line"><span class="keyword">case</span> reflect.UnsafePointer:</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">tmp := reflect.New(tp).Elem()</span><br><span class="line">tmp.Set(val)</span><br><span class="line"><span class="keyword">return</span> tmp.Interface()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CloneArray 克隆一个数组，包含length和内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloneArray</span><span class="params">(in <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(out <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">typ := reflect.TypeOf(in)</span><br><span class="line">val := reflect.ValueOf(in)</span><br><span class="line">length := val.Len()</span><br><span class="line">newArray := reflect.New(typ).Elem()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line"><span class="comment">// 取出原来数组的值</span></span><br><span class="line">tmp := val.Index(i)</span><br><span class="line">tmpVal := reflect.ValueOf(tmp.Interface())</span><br><span class="line">newArray.Index(i).Set(tmpVal)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArray.Interface()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CloneMap 克隆一个Map对象，包含内部数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloneMap</span><span class="params">(in <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(out <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">typ := reflect.TypeOf(in)</span><br><span class="line">val := reflect.ValueOf(in)</span><br><span class="line"></span><br><span class="line">keys := val.MapKeys()</span><br><span class="line">newMap := reflect.MakeMap(typ)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> keys &#123;</span><br><span class="line">tmp := val.MapIndex(kv)</span><br><span class="line">ctmp := reflect.ValueOf(DeepCopy(tmp.Interface()))</span><br><span class="line">newMap.SetMapIndex(kv, ctmp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newMap.Interface()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CloneSlice 克隆切片对象和内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloneSlice</span><span class="params">(in <span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(out <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">typ := reflect.TypeOf(in)</span><br><span class="line">val := reflect.ValueOf(in)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cap</span> := val.Cap()</span><br><span class="line">length := val.Len()</span><br><span class="line">newSlice := reflect.MakeSlice(typ, length, <span class="built_in">cap</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">tmp := val.Index(i)</span><br><span class="line">ctmp := reflect.ValueOf(DeepCopy(tmp.Interface()))</span><br><span class="line">newSlice.Index(i).Set(ctmp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newSlice.Interface()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CloneStruct 克隆结构体</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CloneStruct</span><span class="params">(in <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">typ := reflect.TypeOf(in)</span><br><span class="line">val := reflect.ValueOf(in)</span><br><span class="line">num := typ.Elem().NumField()</span><br><span class="line">newStruct := reflect.New(typ).Elem()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; num; i++ &#123;</span><br><span class="line">tmp := val.Field(i)</span><br><span class="line">ctmp := reflect.ValueOf(DeepCopy(tmp.Interface()))</span><br><span class="line">newStruct.Field(i).Set(ctmp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newStruct.Interface()</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>这其中感觉最重要的就是三个东西，一个是reflect.New 生成一个新的Value对象，类型和传入的一致。 new一个新的对象后要给它赋值，用的是Set(),Set需要的类型是Value，也就是说从另一个对象读出Value，然后new一个新的对象，再把值set进去，就实现了一个简单类型的copy。最后一个是将Value类型转化为interface的  Value.Interface()，返回的是interface{}类型，可以和任何类型进行转化，但是Value是不行的。</p><p>TODO：需要继续探索一下，如何可以复制func、chan这种特殊的类型，以及复制的意义是什么</p>]]></content>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go知识点收集</title>
      <link href="/2018/07/04/go%E7%9F%A5%E8%AF%86%E7%82%B9%E6%94%B6%E9%9B%86/"/>
      <url>/2018/07/04/go%E7%9F%A5%E8%AF%86%E7%82%B9%E6%94%B6%E9%9B%86/</url>
      <content type="html"><![CDATA[<p>使用go中遇到的小问题，记录和回顾用  <br>  <a id="more"></a></p><h3 id="知识点记录">  <a href="#知识点记录" class="headerlink" title="知识点记录"></a>知识点记录</h3><h4 id="用切片的指针取值时报错">  <a href="#用切片的指针取值时报错" class="headerlink" title="用切片的指针取值时报错"></a>用切片的指针取值时报错</h4><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">a := &amp;[]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">b := *a[<span class="number">0</span>] <span class="comment">// 这里说不能通过指针对应索引的值</span></span><br></pre>      </td>    </tr>  </table></figure><p>其实这时一个优先级的问题，我开始认为的事优先得到  <code>*a</code>然后取对应的0，但是取索引对应的值优先级更高  <code>a[0]</code>，这时就不对了</p><p>  <code>(*a)[0]</code>这样就OK了</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>算法200题训练（一）最长递增子序列优化</title>
      <link href="/2018/07/02/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/02/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p>将最长递增子序列的算法复杂度在原来的基础上优化到O(N*logN)  <br>  <a id="more"></a></p><h3 id="最长递增子序列优化">  <a href="#最长递增子序列优化" class="headerlink" title="最长递增子序列优化"></a>最长递增子序列优化</h3><p>上一篇的  <a href="https://blog.whyming.com/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/" target="_blank" rel="noopener">最长递增子序列</a>最终实现的时间复杂度为  <strong>O(N^2)</strong>，现在将要想办法把时间复杂度降到  <strong>O(N*logN)</strong>，且空间复杂度不变。</p><p>上一篇中从代码可以看出两层的for循环，最外层的N是避免不了的，那么里面那层，却存在优化的可能。让我们复习一下里面的那层循环</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">for</span> j, tmp := <span class="keyword">range</span> L[:i] &#123;</span><br><span class="line"><span class="keyword">if</span> tmp &lt; item &#123;</span><br><span class="line">R[i] = max(R[i], R[j]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>这层在做什么呢，循环数组i以前的部分，找到比L[i]更小的数，然后去的这些数中最大的那个+1</p><p>举例  <code>L=[2,1,6,4,5,2,7,4]</code>，求R[3]的时候</p><p>  <img src="https://blog.whyming.com/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/R2.svg" alt="R3"></p><p>这是后L[3]=4,比L[0]=2、L[1]=1都大，且R[0]和R[1]都等于1，所以R[3]=2。  <br>再深入考虑一下，R[0]和R[1]都是1，那么有必要保存两个吗？如果只保留一个R[0]呢，有什么影响吗？如果只保留一个R[1]有什么影响吗？只保留R[0]不可以，因为当i=5的时候L[5]=2,本来R[5]应该等于2的，这样只能为1了。所以当R中两个数相等的时候只需要保留对应L小的那个，就可以不影响后面的数在这个基础上追加变长，因为有一个小的数保证序列长度了，要一个那么大的数干什么，影响后面的发展啊。</p><p>同理，  <code>R[2]=3,R[3]=2</code>，那么只保留R[3]就可以了，因为  <code>L[3]=4 &lt; L[2]=6</code>,想象一下，有一个4结尾的长度为2的序列，谁还想得起6结尾同样长度也是2的，因为不管接下来的是5还是7,4结尾的比6结尾的做的都好。</p><p>按照这个思路，两个相同的只保留一个，最终得到的R中将不会有重复的数了，R中实际上存储了两个信息，一个是下标i表示  <strong>对应到L[i]的数结尾</strong>，具体R的值表示的才是子序列长度。 那么个R表的的意思就是：每一个未删除掉的R[i]表示长度为R[i]的子序列中结尾最小的值为L[i]。比如R[5]=2,表示所有长度为2的最小递增子序列中，结尾最小的最小递增子序列的结尾是L[5]=2</p><p>这时让我们整理一下R，把那些删除的在最开始就不要插入，同时让i和R[i]的信息对调一下，变成：  <strong>R[i]表示的是长度为i的最小递增子序列中，结尾最小的那个序列的结尾是R[i]</strong></p><p>下面我们来逐步生成一下R,通过遍历L来逐步更新R,注意R的下标不随L遍历同步增加，为了区分下面用R[j]表示,因为数组的下标是从0开始的，所以我们还需要+1表示长度  <br>i=0的时候,只有一个2，所以长度为0+1的子序列的最小结尾为2  <br>  <img src="./R0.svg" alt="R0"></p><p>i=1,因为1比2小，不能让子序列变长，所以最长递增子序列长度还是1，这时存在两个最长递增子序列，分别是[2]和[1]，长度都是1，但是[1]的结尾比[2]小，所以更新R[0]=1  <br>  <img src="./R1.svg" alt="R1"></p><p>i=2,L[2] = 6, 这时在R中查找小于6的数(而不是在L中)R中只有一个1，意思是目前只存在一个长度为1的最小递增子序列，且结尾为1，因为6&gt;1，所以一定存在一个长度为2，结尾为6的最小递增子序列。  <br>  <img src="./R2.svg" alt="R2"></p><p>i=3,L[3]=4，这时还是在R中查找，小于4的值，目前R=[1,6]。1&lt;4, 6&gt;4，所以一定存在一个最长递增子序列的长度为2，结尾为4，这时发现，原来已经存在一个长度为2，结尾为6的，4&lt;6  那么这时更新R将长度为2的最长递增子序列的结尾改为4  <br>  <img src="./R3.svg" alt="R3"></p><p>i=4,L[4]=5, 因为在R中没有比5大的数，所以一定存在一个更长的递增子序列，且结尾为5。  <br>  <img src="./R4.svg" alt="R4"></p><p>i=5,L[5]=2, 在R中R[0]=1  <2 ,r[1]="4">2, 所以更新为2，即长度为2的递增子序列，最小结尾为2    <br>    <img src="./R5.svg" alt="R5">  </2></p><p>i=6,L[6]=7,在R中没有找到比7大的数，最大的是R[2]=5,所以一定存在一个长度为4，结尾为7的递增子序列，R[3]=7,  <br>  <img src="./R6.svg" alt="R6"></p><p>i=7,L[7] = 4,第一个比4大的R值就是R[2]=5,所以更新R[2]=4  <br>  <img src="./R7.svg" alt="R7"></p><p>最后R值中存在的最后一个数是R[3] = 7，即存在一个长度为3+1=4的递增子序列，且结尾为7</p><p>那么每次更新或插入R值时的时间复杂度是多少呢？  <br>首先我们把上面的过程表达一下：</p><ul>  <li>当L[i]在R中从左到右找到第一个大于等与L[i]的值时，更新R当前下标对应的值为L[i],见：i=1,i=3,i=5,i=7</li>  <li>当L[i]在R中不存在比L[i]大的值时，向R后追加新的值，方式时R的下标+1，填入L[i],见：i=2,i=4,i=6</li></ul><p>因为R中的数是递增的，所以在R中查找第一个大于L[i]，或者找不到比L[i]大的数都可以用二分法确认，时间复杂度为O(N*logN)</p><p>为什么R中的数是递增的呢？回想一下R的更新和追加新值时的过程，如果这个值特别大，R中没有比它大的，那么这个值会追加在后面，这时保证了有序性，如果这个值找到了一个比它大的值，注意时从左到右的找到第一个比它大的值，那么更新这个值，意思是左边的一定比它小，右边的一定比它大，还是有序的。</p><h4 id="代码-ListBetter">  <a href="#代码-ListBetter" class="headerlink" title="代码 ListBetter"></a>代码 ListBetter</h4><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> LIS</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lis is Longest Increasing Subsequence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lis</span><span class="params">(L []<span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(L) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(L)</span><br><span class="line">&#125;</span><br><span class="line">R := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(L))</span><br><span class="line">R[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, item := <span class="keyword">range</span> L &#123;</span><br><span class="line"><span class="keyword">for</span> j, tmp := <span class="keyword">range</span> L[:i] &#123;</span><br><span class="line"><span class="keyword">if</span> tmp &lt; item &#123;</span><br><span class="line">R[i] = max(R[i], R[j]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = max(result, R[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListBetter 时间复杂度为O(N*logN)的最长递增子序列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ListBetter</span><span class="params">(L []<span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(L) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(L)</span><br><span class="line">&#125;</span><br><span class="line">R := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(L))</span><br><span class="line">R[<span class="number">0</span>] = L[<span class="number">0</span>]</span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, item := <span class="keyword">range</span> L &#123;</span><br><span class="line">index := getIndex(R[:result+<span class="number">1</span>], item)</span><br><span class="line">R[index] = item</span><br><span class="line"><span class="keyword">if</span> index &gt; result &#123;</span><br><span class="line">result = index</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找第一个大于target的数的下标，如果没有比target大的，返回最后一个数的下标+1即切片长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIndex</span><span class="params">(R []<span class="keyword">int</span>, target <span class="keyword">int</span>)</span> <span class="params">(index <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(R) &lt;= <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> R[<span class="built_in">len</span>(R)<span class="number">-1</span>] &lt; target &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(R)</span><br><span class="line">&#125;</span><br><span class="line">start := <span class="number">0</span></span><br><span class="line">end := <span class="built_in">len</span>(R) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">i := (start + end) / <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> ; i &gt; start; i = (start + end) / <span class="number">2</span> &#123;</span><br><span class="line"><span class="keyword">if</span> target == R[i] &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> target &lt; R[i] &#123;</span><br><span class="line">end = i</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">start = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> R[start] &gt; target &#123;</span><br><span class="line"><span class="keyword">return</span> start</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> end</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="UT">  <a href="#UT" class="headerlink" title="UT"></a>UT</h4><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> LIS</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"testing"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLis</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">s []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name       <span class="keyword">string</span></span><br><span class="line">args       args</span><br><span class="line">wantResult <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">"empty"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;&#125;&#125;, wantResult: <span class="number">0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"onlyOne"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">2</span>&#125;&#125;, wantResult: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"none"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;, wantResult: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"full"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;, wantResult: <span class="number">6</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"normal"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>&#125;&#125;, wantResult: <span class="number">4</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> gotResult := Lis(tt.args.s); gotResult != tt.wantResult &#123;</span><br><span class="line">t.Errorf(<span class="string">"Lis() = %v, want %v"</span>, gotResult, tt.wantResult)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestListBetter</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">L []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name       <span class="keyword">string</span></span><br><span class="line">args       args</span><br><span class="line">wantResult <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">"onlyOne"</span>, args: args&#123;L: []<span class="keyword">int</span>&#123;<span class="number">5</span>&#125;&#125;, wantResult: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"two"</span>, args: args&#123;L: []<span class="keyword">int</span>&#123;<span class="number">4</span>, <span class="number">8</span>&#125;&#125;, wantResult: <span class="number">2</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"towButOne"</span>, args: args&#123;L: []<span class="keyword">int</span>&#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;, wantResult: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"multiNumbers"</span>, args: args&#123;L: []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>&#125;&#125;, wantResult: <span class="number">4</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"multiIncreasing"</span>, args: args&#123;L: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;&#125;, wantResult: <span class="number">7</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> gotResult := ListBetter(tt.args.L); gotResult != tt.wantResult &#123;</span><br><span class="line">t.Errorf(<span class="string">"ListBetter() = %v, want %v"</span>, gotResult, tt.wantResult)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_getIndex</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">R      []<span class="keyword">int</span></span><br><span class="line">target <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name      <span class="keyword">string</span></span><br><span class="line">args      args</span><br><span class="line">wantIndex <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">"onlyOneAppend"</span>, args: args&#123;R: []<span class="keyword">int</span>&#123;<span class="number">2</span>&#125;, target: <span class="number">5</span>&#125;, wantIndex: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"onlyOneReplace"</span>, args: args&#123;R: []<span class="keyword">int</span>&#123;<span class="number">7</span>&#125;, target: <span class="number">5</span>&#125;, wantIndex: <span class="number">0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"multiNumbersFirst"</span>, args: args&#123;R: []<span class="keyword">int</span>&#123;<span class="number">6</span>, <span class="number">7</span>&#125;, target: <span class="number">5</span>&#125;, wantIndex: <span class="number">0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"multiNumbers"</span>, args: args&#123;R: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">19</span>&#125;, target: <span class="number">16</span>&#125;, wantIndex: <span class="number">6</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"multiNumbersLitter"</span>, args: args&#123;R: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">47</span>&#125;, target: <span class="number">2</span>&#125;, wantIndex: <span class="number">1</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> gotIndex := getIndex(tt.args.R, tt.args.target); gotIndex != tt.wantIndex &#123;</span><br><span class="line">t.Errorf(<span class="string">"getIndex() = %v, want %v"</span>, gotIndex, tt.wantIndex)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法200题训练（一）最长递增子序列</title>
      <link href="/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83%EF%BC%88%E4%B8%80%EF%BC%89%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>最长递增子序列问题：已知一个序列，包含正数、负数和0，递增子序列指的是，子序列的顺序和已知序列相同，但是不要连续，同时要求后面的数大于前面的数。求最长的子序列的长度  <br>例：已知：&lt;2,1,3,9,4,7,5,2&gt;  <br>最长递增子序列为：&lt;1,3,4,7&gt;或者&lt;1,3,4,5&gt;  <br>答案为 4  <br>  <a id="more"></a></p><h2 id="最长递增子序列问题">  <a href="#最长递增子序列问题" class="headerlink" title="最长递增子序列问题"></a>最长递增子序列问题</h2><h3 id="题目">  <a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>已知一个序列，包含正数、负数和0，递增子序列指的是，子序列的顺序和已知序列相同，但是不要连续，同时要求后面的数大于前面的数。求最长的子序列的长度</p><p>例：已知：  <code>&lt;2,1,6,4,5,2,7,4&gt;</code></p><p>最长递增子序列为：  <code>&lt;2,4,5,7&gt;</code>或者  <code>&lt;1,4,5,7&gt;</code></p><p>答案为  <code>4</code></p><h3 id="解法一：">  <a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><p>已知数组为L  <br>设R[i]表示，必须以L[i]结尾的  <strong>    <code>最长递增子序列</code>  </strong>的长度</p><p>R[i]计算过程就是求出结果的过程，只要用一个变量记录R中的最大值，就可以得到最终结果</p><p>R的计算是这样的，首先R[0] = 1,因为只有一个数的长度为1</p><p>然后R[i]的计算是这样的：用L[i]和L[0]到L[i-1]所有数进行比较，如果L[i]更大，那么记下这个数的下标,比如i=3的时候，L[3]=4;其中L[0]、L[1]都小于L[3],取出这些下标0、1，然后在R中查找对应的数值中最大的+1，即MAX(R[0],R[1])+1  =&gt; 2,那么R[3] = 2. </p><p>因为R[i]中记录了以L[i]结尾的  <strong>    <code>最长递增子序列</code>  </strong>长度，那么只要某个数大于L[i],那么必然存在一个长度为R[i]+1的  <strong>    <code>最长递增子序列</code>  </strong>，这个  <strong>    <code>最长递增子序列</code>  </strong>就是以L[i]结尾的那个序列再加上这个新的数。</p><p>例：  <br>  <img src="./origin_list.svg" alt="L"></p><p>i=0;R[0] = 1,因为必须以L[0]结尾的序列只有  <2>,长度为1    <br>    <img src="./R0.svg" alt="R0">  </2></p><p>i=1;比较L[1]和L[0],没有找到比L[1]小的数，那么R[1] = 1,即以L[1]结尾的  <strong>    <code>最长递增子序列</code>  </strong>  <br>  <img src="./R1.svg" alt="R1"></p><p>i=2;用L[2]比较L[0]和L[1],6比1和2都大,然后取R[0]R[1]中最大的值+1，R[2] = Max(R[0],R[1])+1 = 2  <br>  <img src="./R2.svg" alt="R2"></p><p>i=3;用L[3]比较L[0]~L[2],因为4&lt;6,所以只取0和1下标，R[3] = Max(R[0],R[1])+1 = 2  <br>  <img src="./R3.svg" alt="R3"></p><p>i=4; 用L[4]比较L[0]~L[3],因为L[4]=5&gt;L[0],5&gt;L[1],5&gt;[3],所以R[4] = Max(R[0],R[1],R[3])+1  = 3  <br>  <img src="./R4.svg" alt="R4"></p><p>i=5; 用L[5]比较L[0]~L[4], 因为L[5]=2,只有L[5]&gt;L[1], 所以R[5] = R[1] + 1 = 2  <br>  <img src="./R5.svg" alt="R5"></p><p>i=6,用L[6]比较L[0]~L[5],因为L[6]比前面所有数都大，所以R[6] = Max(R[0]…R[5])+1 = 4  <br>  <img src="R6.svg" alt="R6"></p><p>i=7;用L[7]比较L[0]~L[6],L[7]=4&gt;L[0],4&gt;L[1],4&gt;L[5],所以R[7] = Max(R[0],R[1],R[5])  + 1 = 3  <br>  <img src="R6.svg" alt="R7"></p><p>len = Max(R[0]…R[7]) = 4</p><p>算法复杂度O(N^2),N*N第一个N来自于数组从头到尾的遍历，第二个N来自于每次需要和i以前的对比，取得最大的值+1  <br>len可以每次更新R[i]的时候更新</p><h3 id="go代码">  <a href="#go代码" class="headerlink" title="go代码"></a>go代码</h3><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> LIS</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lis is Longest Increasing Subsequence</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lis</span><span class="params">(s []<span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(s) &lt;= <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line">R := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">R[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">result = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i, item := <span class="keyword">range</span> s &#123;</span><br><span class="line"><span class="keyword">for</span> j, tmp := <span class="keyword">range</span> s[:i] &#123;</span><br><span class="line"><span class="keyword">if</span> tmp &lt; item &#123;</span><br><span class="line">R[i] = max(R[i], R[j]+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">result = max(result, R[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>UT</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">package</span> LIS</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"testing"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestLis</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> args <span class="keyword">struct</span> &#123;</span><br><span class="line">s []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line">tests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">name       <span class="keyword">string</span></span><br><span class="line">args       args</span><br><span class="line">wantResult <span class="keyword">int</span></span><br><span class="line">&#125;&#123;</span><br><span class="line">&#123;name: <span class="string">"empty"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;&#125;&#125;, wantResult: <span class="number">0</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"onlyOne"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">2</span>&#125;&#125;, wantResult: <span class="number">1</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"full"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;&#125;, wantResult: <span class="number">6</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">"normal"</span>, args: args&#123;s: []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">4</span>&#125;&#125;, wantResult: <span class="number">4</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line">t.Run(tt.name, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> gotResult := Lis(tt.args.s); gotResult != tt.wantResult &#123;</span><br><span class="line">t.Errorf(<span class="string">"Lis() = %v, want %v"</span>, gotResult, tt.wantResult)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="优化">  <a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>可以优化的地方在于计算R[i]的时候，可以让L[i]和前面的数比较加速，因为如果R[j]和R[k] 都等于M，且j&lt;k,那么只要L[i]只要和L[j]比较就可以了，而且R[j]和R[k]只要保存一个就可以了。下期完整介绍算法复杂度为  <strong>O(N*logN)</strong>的最长递增子序列</p>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法200题训练</title>
      <link href="/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83/"/>
      <url>/2018/06/27/%E7%AE%97%E6%B3%95200%E9%A2%98%E8%AE%AD%E7%BB%83/</url>
      <content type="html"><![CDATA[<h2 id="算法200题训练">  <a href="#算法200题训练" class="headerlink" title="算法200题训练"></a>算法200题训练</h2><p>加强算法概念和算法思考方式，向左老师学习，先练200题，中间适当穿插理论知识学习</p><p>目前思路：</p><ul>  <li>每周两题，以见过的，且有完整分析的经典问题为主</li>  <li>20题后开始按系统查找算法题，集中突击不同类型算题，如二叉树，字符串匹配等，以经典问题为主。</li>  <li>每10题左右增加一篇总结和回顾</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Nsq源码学习笔记（一）----nsqd启动</title>
      <link href="/2018/06/08/Nsq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89----nsqd%E5%90%AF%E5%8A%A8/"/>
      <url>/2018/06/08/Nsq%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89----nsqd%E5%90%AF%E5%8A%A8/</url>
      <content type="html"><![CDATA[<p>nsqd启动代码学习  <br>  <a id="more"></a></p><h4 id="版本：1-0-1-alpha">  <a href="#版本：1-0-1-alpha" class="headerlink" title="版本：1.0.1-alpha"></a>版本：1.0.1-alpha</h4><h3 id="入口">  <a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>nsqd的入口代码位于：  <code>$GOPATH//github.com/nsqio/nsq/apps/nsqd/nsqd.go</code></p><p>nsqd代码在  <code>$GOPATH//github.com/nsqio/nsq/nsqd</code></p><h3 id="main函数">  <a href="#main函数" class="headerlink" title="main函数"></a>main函数</h3><p>入口函数就是  <code>main</code></p><p>  <code>main</code> 一共4行，run一个  <code>program.Start</code>直到收到结束信息（Control+C或是kill）</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre>      </td>      <td class="code">        <pre><span class="line">prg := &amp;program&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := svc.Run(prg, syscall.SIGINT, syscall.SIGTERM); err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h3 id="启动过程">  <a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>  <code>program.Start</code> 就是启动的主要内容分别如下：</p><ul>  <li>    <a href="#参数解析">解析参数，存入opts</a>  </li>  <li>通过opts new一个nsqd</li>  <li>加载数据，指的是从本地文件加载topic和topic的channel</li>  <li>保存数据回本地文件</li>  <li>进入nsqd.Main</li></ul><h4 id="参数解析">  <a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h4><p>参数解析使用的是go自带的  <code>flag</code>包，解析  <code>nsqd --help</code>中参数，其中  <code>options.Resolve(opts, flagSet, cfg)</code>作用还不能确定，稍后补上</p><h4 id="通过opts-new一个nsqd">  <a href="#通过opts-new一个nsqd" class="headerlink" title="通过opts new一个nsqd"></a>通过opts new一个nsqd</h4><p>如果通过options创建一个nsqd，首先看一下nsqd结构</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="keyword">type</span> NSQD <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// 64bit atomic vars need to be first for proper alignment on 32bit platforms</span></span><br><span class="line">clientIDSequence <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">sync.RWMutex</span><br><span class="line"></span><br><span class="line">opts atomic.Value</span><br><span class="line"></span><br><span class="line">dl        *dirlock.DirLock <span class="comment">// 本地数据文件目录的锁</span></span><br><span class="line">isLoading <span class="keyword">int32</span> <span class="comment">// 是否处于加载本地数据过程中</span></span><br><span class="line">errValue  atomic.Value</span><br><span class="line">startTime time.Time <span class="comment">// 启动时间</span></span><br><span class="line"></span><br><span class="line">topicMap <span class="keyword">map</span>[<span class="keyword">string</span>]*Topic <span class="comment">// 所有topic存储在这里</span></span><br><span class="line"></span><br><span class="line">lookupPeers atomic.Value</span><br><span class="line"></span><br><span class="line">tcpListener   net.Listener</span><br><span class="line">httpListener  net.Listener</span><br><span class="line">httpsListener net.Listener</span><br><span class="line">tlsConfig     *tls.Config <span class="comment">// tls配置信息</span></span><br><span class="line"></span><br><span class="line">poolSize <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">notifyChan           <span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">optsNotificationChan <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">exitChan             <span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// 退出信号</span></span><br><span class="line">waitGroup            util.WaitGroupWrapper</span><br><span class="line"></span><br><span class="line">ci *clusterinfo.ClusterInfo</span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>结构中每个属性的意义和作用，随着创建和启动逐步完善  <br>创建nsqd实例前先做了两件事：</p><ul>  <li>首先检查了是否指定了    <code>data-path</code>，如果没有使用当前目录，为什么创建实例前一定要确定目录，稍后提到</li>  <li>给options创建了一个Logger，为什么不是给nsqd增加Logger而是给了options，还有怎么使用，稍后需要注意一下。(填坑：nsqd专门创建logger函数，内部使用的就是options.Logger，对外的实现是n.logf)</li></ul><p>创建实例，nsqd没有一次创建所有属性</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre>      </td>      <td class="code">        <pre><span class="line">n := &amp;NSQD&#123;</span><br><span class="line">startTime:            time.Now(), <span class="comment">// 当前时间，也就是启动时间</span></span><br><span class="line">topicMap:             <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]*Topic), <span class="comment">// 这个很关键了，需要下次专门介绍，用于保存所有topic的结构</span></span><br><span class="line">exitChan:             <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>), <span class="comment">// 退出信号</span></span><br><span class="line">notifyChan:           <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;), <span class="comment">// 还不知道，稍后填坑</span></span><br><span class="line">optsNotificationChan: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>), <span class="comment">// 不知道，稍后填坑</span></span><br><span class="line">dl:                   dirlock.New(dataPath), <span class="comment">// 上面提到的数据目录，为了防止多个进程使用同一个目录，需要对目录加锁，稍后详细提到</span></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><p>初始化http api client  <code>n.ci = clusterinfo.New(n.logf, httpcli)</code>,同时日志输出保持一致</p><p>指定日志输出等级  <code>opts.logLevel, err = lg.ParseLogLevel(opts.LogLevel, opts.Verbose)</code></p><p>给数据目录上锁，应该是独占锁，保证其他进程不能在上锁，Ulock动作在Exit才执行，也就是说整个进程执行期间，都是锁住的</p><p>接下来是一些参数检查，和tls配置检查  <br>然后返回整个nsqd的实例</p><h4 id="加载本地数据">  <a href="#加载本地数据" class="headerlink" title="加载本地数据"></a>加载本地数据</h4><p>  <code>nsqd.LoadMetadata()</code>从本地文件加载数据  <br>文件加载过程专门使用atomic标示加载过程</p><figure class="highlight go">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br></pre>      </td>      <td class="code">        <pre><span class="line">atomic.StoreInt32(&amp;n.isLoading, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> atomic.StoreInt32(&amp;n.isLoading, <span class="number">0</span>)</span><br></pre>      </td>    </tr>  </table></figure><p>应该是为了兼容老的版本，加载的时候需要加载两个文件，其中一个包含ID信息是老版本的文件，读取两个文件后进行比对，如果不一致，返回错误，要求删除其中一个。如果只有一个文件，则只加载该文件的数据，数据的格式是json,内容是这个样子</p><figure class="highlight json">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre>      </td>      <td class="code">        <pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"topics"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"channels"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"name"</span>: <span class="string">"ch1"</span>,</span><br><span class="line">                    <span class="attr">"paused"</span>: <span class="literal">false</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"tp1"</span>,</span><br><span class="line">            <span class="attr">"paused"</span>: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.1-alpha"</span></span><br><span class="line">&#125;</span><br></pre>      </td>    </tr>  </table></figure><h4 id="保存数据回本地文件">  <a href="#保存数据回本地文件" class="headerlink" title="保存数据回本地文件"></a>保存数据回本地文件</h4><p>topics在每次创建/删除是都会同步到文件，添加或删除channels也会同步到文件，使用的的方法就是  <code>PersistMetadata</code>,以后这详细介绍如何触发保存到文件动作，这里只是简单介绍一下保存过程中主要做了哪些事</p><p>主要分为两个部分</p><ul>  <li>嵌套循环topic 和 topic内的channel，写入文件</li>  <li>通过创建tmp文件，在rename方式写入数据，然后再创建一个软连接</li></ul><h5 id="第一个部分是获取元数据">  <a href="#第一个部分是获取元数据" class="headerlink" title="第一个部分是获取元数据"></a>第一个部分是获取元数据</h5><p>遍历nsq.topicMap, topicMap是目前我认为最重要的结构，主要的数据都保存在这个结构中。遍历topicMap中的每一个topic，只取出topic的name和paused两个属性值保存下来，然后便利topic.channelMap同样只取出name和paused连个属性，在这两层循环中都判断了是否是临时的，ephemeral这个以后还会见到很多次，topic或是channel的name中带有  <code>#ephemeral</code>都被认为是临时的，不会读取，也不会保存。取出所有topic和channel后序列化成json保存入临时文件。</p><h5 id="临时文件和软连接">  <a href="#临时文件和软连接" class="headerlink" title="临时文件和软连接"></a>临时文件和软连接</h5><p>写临时文件然后在rename到真正要保存的文件名，这个属于标准流程，肯定不能直接写目标文件，万一出错或发生意外避免影响到源文件/目标文件，写入成功后在rename安全多了。</p><p>为什么创建软连接，其实上面加载过程中加载的两个文件就来源于这里，如果是软连接，读出来的内容自然一样，看来还是为了兼容以前的版本。</p><p>做完上面的事，就要进入真正的启动和监听部分  <code>nsq.Main</code></p>]]></content>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> Nsq </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>奇怪的问题记录</title>
      <link href="/2018/06/08/%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/06/08/%E5%A5%87%E6%80%AA%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>一些在工作中遇到的奇怪问题的记录，方便回忆查找  <br>  <a id="more"></a></p><h3 id="Mac-OS-X-下目录名大小写不敏感问题">  <a href="#Mac-OS-X-下目录名大小写不敏感问题" class="headerlink" title="Mac OS X 下目录名大小写不敏感问题"></a>Mac OS X 下目录名大小写不敏感问题</h3><p>在Terminal里，  <code>cd</code> 命令可以进入一个忽略大小写的目录，比如我有一个目录，  <code>~/Go</code>,我可以  <code>cd ~/Go</code>,也可以  <code>cd ~/go</code>，实际上这两个命令进入的是同一个目录。进而发现Mac默认文件和目录是不区分大小写的（这个有点反*inux），但是多数程序是关系区分大小写的。所以就出现问题了。</p><p>在一个Nsq的项目里使用的vendor作依赖管理，用dep也已经下载好了，但是test通不过，build也不行，说找不到package，而且从错误信息上看，只搜索了GOPATH和GOROOT，检查vendor目录，依赖包都在，怎么也找不到原因，最后猜测可能和目录大小写有关，因为之前是  <code>cd go</code>而目录名是Go，这次  <code>cd Go</code>然后逐层进入，再次test，果然好了</p><blockquote>  <p>总结：OS X 默认不区分大小写，在Terminal使用的时候要注意目录名称，或者统一使用小写避免问题，另外可以新建一个大小写敏感的分区</p></blockquote><p>  <a href="http://blog.bihe0832.com/mac-disk-utility.html" target="_blank" rel="noopener">OS X 中设置大小写敏感的分区并切换</a></p>]]></content>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac下使用dokcer搭建开发环境记录</title>
      <link href="/2018/06/01/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8dokcer%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/"/>
      <url>/2018/06/01/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8dokcer%E6%90%AD%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<pre><code>搭建环境中一些知识点的记录，帮助自己回忆一些遇到的问题</code></pre><a id="more"></a><h2 id="背景">  <a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>工作内容包含多个项目，对应语言为php，不同项目独立维护，通过不同的域名接入，系统之间通过http交换信息。目标是实现一个一键式脚本，搭建一个开发环境可以同时支持多个项目运行，其实就是Nginx+php-fpm的docker+git  checkout代码，然后  <code>docker-compose</code>一起管理。  <br>有两个注意点</p><ul>  <li>多个项目同时存在，需要通过域名区分每个项目的入口地址</li>  <li>多个项目在不同的git项目上，最好能一次性准备好</li></ul><h3 id="阿里云的docker源">  <a href="#阿里云的docker源" class="headerlink" title="阿里云的docker源"></a>阿里云的docker源</h3><p>为了解决docker pull 的问题优先使用的是  <a href="https://dev.aliyun.com/search.html" target="_blank" rel="noopener">阿里云</a>的仓库，在上面找的nginx和php-fpm，需要注意的是上面的发布的image不一定都是好用的，pull之后检查一下是否符合需求。</p><h3 id="build自己的image">  <a href="#build自己的image" class="headerlink" title="build自己的image"></a>build自己的image</h3><p>制作这个一键式脚本最花费时间的地方是，想要重新build一个image，默认包含nginx的配置。不同域名对应不同的项目，一个docker通过nginx配置同时支持多个项目。当然配置域名后要在本地修改hosts文件才能正常访问。制作image就需要写一个Dockerfile，目的就是copy一些  <code>nginx_xxx.conf</code>的配置文件进去，其他的信息不用修改。在这里学到了两个知识点：</p><ul>  <li>使用    <code>doker inspect [image_id]</code>可以查看某个镜像的当前设置，包含    <code>CMD</code>    <code>Volumes</code>    <code>EXPOSE</code>等，如下图</li>  <li>在基于原来的image制作新的时，只需要设置需要修改的部分即可，不需要每个Dokcerfile都填写完全的信息，比如我这个需求就是添加一些配置文件，那么Dockerfile就可以只有    <code>FROM</code>和    <code>COPY</code>  </li></ul><p>  <img src="/img/docker-inspect.png" alt=""></p><h3 id="docker-compose关联多个docker">  <a href="#docker-compose关联多个docker" class="headerlink" title="docker-compose关联多个docker"></a>docker-compose关联多个docker</h3><p>制作工程中还有一个点学习到的就是docker-compose.yml中可以通过links方便的的吧两个docker连通，这个词可能不准确，我的理解是可能互相认识，可以通过名字访问到对方</p><h3 id="mysql密码问题">  <a href="#mysql密码问题" class="headerlink" title="mysql密码问题"></a>mysql密码问题</h3><p>运行mysql的docker时，需要指定一个重要的环境变量  <code>MYSQL_ROOT_PASSWORD</code>，最好加上  <code>MYSQL_ROOT_HOST=%</code>，但是好多地方都没有说明挂载data的问题，自己就遇到了设置了  <code>MYSQL_ROOT_PASSWORD</code>但是连接失败的问题，原因就在挂载  <code>/var/lib/msyql</code>这个目录的时候里面有上次运行的文件，导致没能将新的密码设置进去。简单的方法就是第一次启动前确认挂载的目录是空的，保证这次启动时完全初始化的。</p><h3 id="sudo-和重定向问题">  <a href="#sudo-和重定向问题" class="headerlink" title="sudo 和重定向问题"></a>sudo 和重定向问题</h3><p>在制作一键式脚本时，因为要更新hosts文件，需要执行类似  <br>  <code>sudo echo &quot;$hosts_conf&quot; &gt;&gt;/etc/hosts</code>  <br>一直提示  <code>Permission denied</code>，感觉sudo没起作用，实际上是sudo只授权给了  <code>echo</code>而重定向  <code>&gt;&gt;</code>也需要sudo权限，搜索结果y  <br>  <code>sudo sh -c &quot;echo \&quot;$host_config\&quot; &gt;&gt; /etc/hostscd &quot;</code>  <br>感觉上有点像eval的样子，将所有动作都包含在一起了</p><h3 id="sed替换路径问题">  <a href="#sed替换路径问题" class="headerlink" title="sed替换路径问题"></a>sed替换路径问题</h3><p>sed替换字符串中的某些特定字符很简单</p><p>  <code>sed &quot;s/abc/ABC/g&quot; filename.txt</code></p><p>使用变量的话</p><p>  <code>sed &quot;s/$src/$dst/g&quot; filename.txt</code></p><p>但是如果变量中带有  <code>/</code>就又问题，一个方法是保证变量内的  <code>/</code>被替换为  <code>\/</code>转义后在传进来，不过还有一个更好的办法</p><p>  <code>sed &quot;s#$src#$dst#g&quot;</code></p><p>这样  <code>/</code>就不需要转义了</p><h3 id="host问题">  <a href="#host问题" class="headerlink" title="host问题"></a>host问题</h3><p>由于多个php项目都在同一个挂载目录，同时不同项目使用了不同的域名，且不同项目见接口调用使用了域名进行访问。一开始只有本机配置了hosts文件，保证本地访问时可以通过127.0.0.1  访问正常，但是遇到项目间接口调用的时候出现了Connection Refuse。原因是php-fpm docker内查找域名的时候没有找到，所以通过本机得到了域名指向的是127.0.0.1，于是访问本地，然后出错了，因为对于本机来说127.0.0.1已经和docker做了端口映射，但是php-fpm内部访问的自己内部的端口，需要让php-fpm访问nginx的端口就对了。最近解决方法是给每个容器指定ip，且给php-fpm增加host配置</p><figure class="highlight yml">  <table>    <tr>      <td class="gutter">        <pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre>      </td>      <td class="code">        <pre><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">      finance-network:</span></span><br><span class="line"><span class="attr">        ipv4_address:</span> <span class="number">172.28</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line"><span class="attr">   extra_hosts:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"dev.xxx.xxx.com:172.28.0.11"</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line"><span class="attr">  finance-network:</span></span><br><span class="line"><span class="attr">    driver:</span> <span class="string">bridge</span></span><br><span class="line"><span class="attr">    ipam:</span></span><br><span class="line"><span class="attr">      driver:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">      config:</span></span><br><span class="line"><span class="attr">        - subnet:</span> <span class="number">172.28</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br></pre>      </td>    </tr>  </table></figure>]]></content>
      
      
        <tags>
            
            <tag> 记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>笔记博客开坑</title>
      <link href="/2018/05/30/%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%9D%91/"/>
      <url>/2018/05/30/%E7%AC%94%E8%AE%B0%E5%8D%9A%E5%AE%A2%E5%BC%80%E5%9D%91/</url>
      <content type="html"><![CDATA[<p>列举一下接下来要开坑的分类  <br>  <a id="more"></a></p><h2 id="开坑分类">  <a href="#开坑分类" class="headerlink" title="开坑分类"></a>开坑分类</h2><ul>  <li>日常吐槽</li>  <li>经验总结</li>  <li>算法学习</li>  <li>go 源码和源码包学习</li>  <li>开源项目和源码学习</li>  <li>自己的项目</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
